; w65c02 assembly code for 'main'
; generated by prog8.codegen.cpu6502.ProgramAndVarsGen on 2023-02-05T11:42:21
; assembler syntax is for the 64tasm cross-assembler
; output options: output=PRG launcher=BASIC zp=KERNALSAFE

.cpu  'w65c02'
.enc  'none'
P8ZP_SCRATCH_B1 = 122
P8ZP_SCRATCH_REG = 123
P8ZP_SCRATCH_W1 = 124    ; word
P8ZP_SCRATCH_W2 = 126    ; word
.weak
P8ESTACK_LO = $0400
P8ESTACK_HI = $0500
.endweak
; ---- basic program with sys call ----
* = $0801
	.word  (+), 2023
	.null  $9e, format(' %d ', prog8_entrypoint), $3a, $8f, ' prog8'
+	.word  0
prog8_entrypoint	; assembly code starts here
	jsr  cx16.init_system
	jsr  cx16.init_system_phase2
	; zeropage is clobbered so we need to reset the machine at exit
	lda  #>sys.reset_system
	pha
	lda  #<sys.reset_system
	pha
	jsr  main.start
	jmp  cx16.cleanup_at_exit

; ---- block: 'main' ----
main	.proc
	;	src line: main.p8:4

; non-zeropage variables

	;	src line: main.p8:6

start	.proc
; program startup initialization
	cld
+       tsx
	stx  prog8_lib.orig_stackpointer    ; required for sys.exit()
	ldx  #255       ; init estack ptr
	clv
	clc
; statements
	;	src line: library:/prog8lib/cx16/textio.p8:17
	lda  #$93
	jsr  txt.chrout
	;	src line: main.p8:8
	jsr  conway.initialize
	;	src line: main.p8:9
prog8_label_1_repeat
	;	src line: main.p8:10
	jsr  conway.next_generation
	;	src line: main.p8:9
	bra  prog8_label_1_repeat
	;	src line: main.p8:6
	rts
; variables

; non-zeropage variables
	.pend
	.pend

; ---- block: 'conway' ----
conway	.proc
	;	src line: main.p8:15

; non-zeropage variables

	;	src line: main.p8:16

initialize	.proc
x 	= 34 	; zp UBYTE
y 	= 35 	; zp UBYTE
; statements
	;	src line: main.p8:17
	;	src line: main.p8:17
	phx
	jsr  txt.width
	sta  x
	plx
	;	src line: main.p8:18
	;	src line: main.p8:18
	phx
	jsr  txt.height
	sta  y
	plx
	;	src line: main.p8:19
	phx
	jsr  txt.height
	tay
	plx
	beq  prog8_label_2_repeatend
	sty  prog8_label_4_counter
prog8_label_3_repeat
	;	src line: main.p8:20
	phx
	jsr  txt.width
	tay
	plx
	beq  prog8_label_5_repeatend
	sty  prog8_label_7_counter
prog8_label_6_repeat
	;	src line: main.p8:21
	jsr  math.rnd
	and  #15
	jsr  txt.color
	;	src line: main.p8:22
	jsr  math.rnd
	sta  cx16.r9L
	;	src line: main.p8:22
	ldy  #5
	jsr  math.divmod_ub_asm
	sta  cx16.r9L
	;	src line: main.p8:22
	lda  cx16.r9L
	bne  prog8_label_8_if_else
	;	src line: main.p8:23
	phx
	ldy  y
	ldx  x
	lda  #$51
	jsr  txt.setchr
	plx
	;	src line: main.p8:24
	phx
	jsr  math.rnd
	and  #15
	pha
	lda  x
	pha
	lda  y
  tay
	plx
	pla
	jsr  txt.setclr
	plx
	bra  prog8_label_9_if_end
prog8_label_8_if_else
	;	src line: main.p8:26
	phx
	ldy  y
	ldx  x
	lda  #$20
	jsr  txt.setchr
	plx
prog8_label_9_if_end
	;	src line: main.p8:28
	dec  x
	dec  prog8_label_7_counter
	bne  prog8_label_6_repeat
prog8_label_5_repeatend
	;	src line: main.p8:30
	dec  y
	;	src line: main.p8:31
	phx
	jsr  txt.width
	sta  x
	plx
	dec  prog8_label_4_counter
	bne  prog8_label_3_repeat
prog8_label_2_repeatend
	;	src line: main.p8:16
	rts
; variables
prog8_label_4_counter = 42
prog8_label_7_counter = 43

; non-zeropage variables
	.pend
	;	src line: main.p8:36

next_generation	.proc
x 	= 36 	; zp UBYTE
y 	= 37 	; zp UBYTE
; statements
	;	src line: main.p8:37
	;	src line: main.p8:37
	phx
	jsr  txt.width
	sta  x
	plx
	;	src line: main.p8:38
	;	src line: main.p8:38
	phx
	jsr  txt.height
	sta  y
	plx
	;	src line: main.p8:39
	phx
	jsr  txt.height
	tay
	plx
	beq  prog8_label_10_repeatend
	sty  prog8_label_12_counter
prog8_label_11_repeat
	;	src line: main.p8:40
	phx
	jsr  txt.width
	tay
	plx
	beq  prog8_label_13_repeatend
	sty  prog8_label_15_counter
prog8_label_14_repeat
	;	src line: main.p8:41
	ldy  y
	lda  x
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_16_if_else
	;	src line: main.p8:42
	lda  x
	ldy  y
	jsr  conway.count_neighbours
	cmp  #2
	bcs  prog8_label_18_if_else
	;	src line: main.p8:43
	phx
	ldy  y
	ldx  x
	lda  #$20
	jsr  txt.setchr
	plx
	bra  prog8_label_19_if_end
prog8_label_18_if_else
	;	src line: main.p8:44
	lda  x
	ldy  y
	jsr  conway.count_neighbours
	cmp  #3
	bcc  prog8_label_20_if_end
	beq  prog8_label_20_if_end
	;	src line: main.p8:45
	phx
	ldy  y
	ldx  x
	lda  #$20
	jsr  txt.setchr
	plx
prog8_label_20_if_end
prog8_label_19_if_end
	bra  prog8_label_17_if_end
prog8_label_16_if_else
	;	src line: main.p8:48
	lda  x
	ldy  y
	jsr  conway.count_neighbours
	cmp  #3
	bne  prog8_label_21_if_end
	;	src line: main.p8:49
	phx
	ldy  y
	ldx  x
	lda  #$51
	jsr  txt.setchr
	plx
	;	src line: main.p8:50
	phx
	jsr  math.rnd
	and  #15
	pha
	lda  x
	pha
	lda  y
  tay
	plx
	pla
	jsr  txt.setclr
	plx
prog8_label_21_if_end
prog8_label_17_if_end
	;	src line: main.p8:53
	dec  x
	dec  prog8_label_15_counter
	bne  prog8_label_14_repeat
prog8_label_13_repeatend
	;	src line: main.p8:56
	dec  y
	;	src line: main.p8:57
	phx
	jsr  txt.width
	sta  x
	plx
	dec  prog8_label_12_counter
	bne  prog8_label_11_repeat
prog8_label_10_repeatend
	;	src line: main.p8:36
	rts
; variables
prog8_label_12_counter = 44
prog8_label_15_counter = 45

; non-zeropage variables
	.pend
	;	src line: main.p8:64

count_neighbours	.proc
y 	= 38 	; zp UBYTE
x 	= 39 	; zp UBYTE
count 	= 40 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  x
	sty  y
; statements
	;	src line: main.p8:64
	;	src line: main.p8:64
	;	src line: main.p8:65
	;	src line: main.p8:65
	stz  count
	;	src line: main.p8:67
	lda  x
	sec
	sbc  #1
	pha
	lda  y
	sec
	sbc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_22_if_end
	;	src line: main.p8:68
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_22_if_end
	;	src line: main.p8:71
	lda  x
	pha
	lda  y
	sec
	sbc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_23_if_end
	;	src line: main.p8:72
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_23_if_end
	;	src line: main.p8:75
	lda  x
	clc
	adc  #1
	pha
	lda  y
	sec
	sbc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_24_if_end
	;	src line: main.p8:76
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_24_if_end
	;	src line: main.p8:79
	lda  x
	sec
	sbc  #1
	pha
	lda  y
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_25_if_end
	;	src line: main.p8:80
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_25_if_end
	;	src line: main.p8:83
	lda  x
	clc
	adc  #1
	pha
	lda  y
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_26_if_end
	;	src line: main.p8:84
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_26_if_end
	;	src line: main.p8:87
	lda  x
	sec
	sbc  #1
	pha
	lda  y
	clc
	adc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_27_if_end
	;	src line: main.p8:88
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_27_if_end
	;	src line: main.p8:91
	lda  x
	pha
	lda  y
	clc
	adc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_28_if_end
	;	src line: main.p8:92
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_28_if_end
	;	src line: main.p8:95
	lda  x
	clc
	adc  #1
	pha
	lda  y
	clc
	adc  #1
  tay
	pla
	jsr  txt.getchr
	cmp  #$51
	bne  prog8_label_29_if_end
	;	src line: main.p8:96
	lda  count
	clc
	adc  #1
	sta  count
prog8_label_29_if_end
	;	src line: main.p8:99
	lda  count
	rts
; variables

; non-zeropage variables
	.pend
	.pend

; ---- block: 'math' ----
math	.proc
	;	src line: library:/prog8lib/math.p8:3

; non-zeropage variables

	;	src line: library:/prog8lib/math.p8:4
; Internal Math library routines - always included by the compiler
; Generic machine independent 6502 code.
;
;  some more interesting routines can be found here:
;	http://6502org.wikidot.com/software-math
;	http://codebase64.org/doku.php?id=base:6502_6510_maths
;


math_store_reg	.byte  0		; temporary storage


multiply_bytes	.proc
	; -- multiply 2 bytes A and Y, result as byte in A  (signed or unsigned)
		sta  P8ZP_SCRATCH_B1         ; num1
		sty  P8ZP_SCRATCH_REG        ; num2
		lda  #0
		beq  _enterloop
_doAdd		clc
		adc  P8ZP_SCRATCH_B1
_loop		asl  P8ZP_SCRATCH_B1
_enterloop	lsr  P8ZP_SCRATCH_REG
		bcs  _doAdd
		bne  _loop
		rts
		.pend


multiply_bytes_into_word	.proc
	; -- multiply 2 bytes A and Y, result as word in A/Y (unsigned)
		sta  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		stx  math_store_reg
		lda  #0
		ldx  #8
		lsr  P8ZP_SCRATCH_B1
-		bcc  +
		clc
		adc  P8ZP_SCRATCH_REG
+		ror  a
		ror  P8ZP_SCRATCH_B1
		dex
		bne  -
		tay
		lda  P8ZP_SCRATCH_B1
		ldx  math_store_reg
		rts
		.pend


multiply_words	.proc
	; -- multiply two 16-bit words into a 32-bit result  (signed and unsigned)
	;      input: A/Y = first 16-bit number, P8ZP_SCRATCH_W1 in ZP = second 16-bit number
	;      output: multiply_words.result  4-bytes/32-bits product, LSB order (low-to-high)
	;      clobbers: A

		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		stx  P8ZP_SCRATCH_REG

mult16		lda  #0
		sta  result+2	; clear upper bits of product
		sta  result+3
		ldx  #16			; for all 16 bits...
-	 	lsr  P8ZP_SCRATCH_W1+1	; divide multiplier by 2
		ror  P8ZP_SCRATCH_W1
		bcc  +
		lda  result+2	; get upper half of product and add multiplicand
		clc
		adc  P8ZP_SCRATCH_W2
		sta  result+2
		lda  result+3
		adc  P8ZP_SCRATCH_W2+1
+ 		ror  a				; rotate partial product
		sta  result+3
		ror  result+2
		ror  result+1
		ror  result
		dex
		bne  -
		ldx  P8ZP_SCRATCH_REG
		rts

result		.byte  0,0,0,0
		.pend


divmod_b_asm	.proc
	; signed byte division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_B1
		tya
		eor  P8ZP_SCRATCH_B1
		php			; save sign
		lda  P8ZP_SCRATCH_B1
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
+		pha
		tya
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make it positive
		tay
+		pla
		jsr  divmod_ub_asm
		sta  _remainder
		plp
		bpl  +
		tya
		eor  #$ff
		sec
		adc  #0			; negate result
		tay
+		rts
_remainder	.byte  0
		.pend


divmod_ub_asm	.proc
	; -- divide A by Y, result quotient in Y, remainder in A   (unsigned)
	;    division by zero will result in quotient = 255 and remainder = original number
		sty  P8ZP_SCRATCH_REG
		sta  P8ZP_SCRATCH_B1
		stx  math_store_reg

		lda  #0
		ldx  #8
		asl  P8ZP_SCRATCH_B1
-		rol  a
		cmp  P8ZP_SCRATCH_REG
		bcc  +
		sbc  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		dex
		bne  -
		ldy  P8ZP_SCRATCH_B1
		ldx  math_store_reg
		rts
		.pend

divmod_w_asm	.proc
	; signed word division: make everything positive and fix sign afterwards
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  P8ZP_SCRATCH_W1+1
		eor  P8ZP_SCRATCH_W2+1
		php			; save sign
		lda  P8ZP_SCRATCH_W1+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W1
		lda  #0
		sbc  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W1+1
+		lda  P8ZP_SCRATCH_W2+1
		bpl  +
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W2
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W2+1
+		tay
		lda  P8ZP_SCRATCH_W2
		jsr  divmod_uw_asm
		plp			; restore sign
		bpl  +
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  #0
		sec
		sbc  P8ZP_SCRATCH_W2
		pha
		lda  #0
		sbc  P8ZP_SCRATCH_W2+1
		tay
		pla
+		rts
		.pend

divmod_uw_asm	.proc
	; -- divide two unsigned words (16 bit each) into 16 bit results
	;    input:  P8ZP_SCRATCH_W1 in ZP: 16 bit number, A/Y: 16 bit divisor
	;    output: P8ZP_SCRATCH_W2 in ZP: 16 bit remainder, A/Y: 16 bit division result
	;    division by zero will result in quotient = 65535 and remainder = divident


dividend = P8ZP_SCRATCH_W1
remainder = P8ZP_SCRATCH_W2
result = dividend ;save memory by reusing divident to store the result

		sta  _divisor
		sty  _divisor+1
		stx  P8ZP_SCRATCH_REG
		lda  #0	        	;preset remainder to 0
		sta  remainder
		sta  remainder+1
		ldx  #16	        ;repeat for each bit: ...

-		asl  dividend		;dividend lb & hb*2, msb -> Carry
		rol  dividend+1
		rol  remainder		;remainder lb & hb * 2 + msb from carry
		rol  remainder+1
		lda  remainder
		sec
		sbc  _divisor		;substract divisor to see if it fits in
		tay	       		;lb result -> Y, for we may need it later
		lda  remainder+1
		sbc  _divisor+1
		bcc  +			;if carry=0 then divisor didn't fit in yet

		sta  remainder+1	;else save substraction result as new remainder,
		sty  remainder
		inc  result		;and INCrement result cause divisor fit in 1 times

+		dex
		bne  -

		lda  result
		ldy  result+1
		ldx  P8ZP_SCRATCH_REG
		rts
_divisor	.word 0
		.pend


randword	.proc
	; -- 16 bit pseudo random number generator into AY
	;    default seed = $00c2 $1137
        ;    routine from https://codebase64.org/doku.php?id=base:x_abc_random_number_generator_8_16_bit
		inc x1
		clc
x1=*+1
		lda #$00	;x1
c1=*+1
		eor #$c2	;c1
a1=*+1
		eor #$11	;a1
		sta a1
b1=*+1
		adc #$37	;b1
		sta b1
		lsr a
		eor a1
		adc c1
		sta c1
		ldy b1
		rts
		.pend

randbyte = randword    ; -- 8 bit pseudo random number generator into A (by just reusing randword)


; ----------- optimized multiplications (stack) : ---------
stack_mul_byte_3	.proc
		; X + X*2
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_3	.proc
		; W*2 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend


stack_mul_byte_5	.proc
		; X*4 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_5	.proc
		; W*4 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend


stack_mul_byte_6	.proc
		; (X*2 + X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_6	.proc
		; (W*2 + W)*2
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_7	.proc
		; X*8 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_7	.proc
		; W*8 - W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_9	.proc
		; X*8 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_9	.proc
		; W*8 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_10	.proc
		; (X*4 + X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_10	.proc
		; (W*4 + W)*2
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_11	.proc
		; (X*2 + X)*4 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_11 is skipped (too much code)

stack_mul_byte_12	.proc
		; (X*2 + X)*4
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_12	.proc
		; (W*2 + W)*4
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_13	.proc
		; (X*2 + X)*4 + X
		lda  P8ESTACK_LO+1,x
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
                clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_13 is skipped (too much code)

stack_mul_byte_14	.proc
		; (X*8 - X)*2
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ESTACK_LO+1,x
                asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

; mul_word_14 is skipped (too much code)

stack_mul_byte_15	.proc
		; X*16 - X
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_15	.proc
		; W*16 - W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_20	.proc
		; (X*4 + X)*4
		lda  P8ESTACK_LO+1,x
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_20	.proc
		; (W*4 + W)*4
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_25	.proc
		; (X*2 + X)*8 + X
		lda  P8ESTACK_LO+1,x
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_25	.proc
		; W = (W*2 + W) *8 + W
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_40	.proc
		lda  P8ESTACK_LO+1,x
		and  #7
		tay
		lda  mul_byte_40._forties,y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_40	.proc
		; (W*4 + W)*8
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_REG
		lda  P8ESTACK_LO+1,x
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_REG
		adc  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		asl  P8ESTACK_LO+1,x
                rol  a
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_50	.proc
		lda  P8ESTACK_LO+1,x
		and  #7
		tay
		lda  mul_byte_50._fifties, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_50	.proc
		; W = W * 25 * 2
		jsr  stack_mul_word_25
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_80	.proc
		lda  P8ESTACK_LO+1,x
		and  #3
		tay
		lda  mul_byte_80._eighties, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_80	.proc
		; W = W * 40 * 2
		jsr  stack_mul_word_40
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_byte_100	.proc
		lda  P8ESTACK_LO+1,x
		and  #3
		tay
		lda  mul_byte_100._hundreds, y
		sta  P8ESTACK_LO+1,x
		rts
		.pend

stack_mul_word_100	.proc
		; W = W * 25 * 4
		jsr  stack_mul_word_25
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_word_320	.proc
		; stackW = stackLo * 256 + stackLo * 64	 (stackHi doesn't matter)
		ldy  P8ESTACK_LO+1,x
		lda  #0
		sta  P8ESTACK_HI+1,x
		tya
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		asl  a
		rol  P8ESTACK_HI+1,x
		sta  P8ESTACK_LO+1,x
		tya
		clc
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

stack_mul_word_640	.proc
		; stackW = (stackLo * 2 * 320)    (stackHi doesn't matter)
		asl  P8ESTACK_LO+1,x
		jmp  stack_mul_word_320
		.pend


; ----------- optimized multiplications (in-place A (byte) and ?? (word)) : ---------
mul_byte_3	.proc
		; A = A + A*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_3	.proc
		; AY = AY*2 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_5	.proc
		; A = A*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_5	.proc
		; AY = AY*4 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend


mul_byte_6	.proc
		; A = (A*2 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
                adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_6	.proc
		; AY = (AY*2 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		tay
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		tya
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_7	.proc
		; A = A*8 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_7	.proc
		; AY = AY*8 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_9	.proc
		; A = A*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_9	.proc
		; AY = AY*8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		rts
		.pend

mul_byte_10	.proc
		; A=(A*4 + A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		rts
		.pend

mul_word_10	.proc
		; AY=(AY*4 + AY)*2
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_11	.proc
		; A=(A*2 + A)*4 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_11 is skipped (too much code)

mul_byte_12	.proc
		; A=(A*2 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_12	.proc
		; AY=(AY*2 + AY)*4
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		ldy  P8ZP_SCRATCH_W1+1
		rts
		.pend

mul_byte_13	.proc
		; A=(A*2 + A)*4 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
                clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

; mul_word_13 is skipped (too much code)

mul_byte_14	.proc
		; A=(A*8 - A)*2
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
                sec
		sbc  P8ZP_SCRATCH_REG
                asl  a
		rts
		.pend

; mul_word_14 is skipped (too much code)

mul_byte_15	.proc
		; A=A*16 - A
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		asl  a
		sec
		sbc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_15	.proc
		; AY = AY * 16 - AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		sec
		sbc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		sbc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_20	.proc
		; A=(A*4 + A)*4
		sta  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		rts
		.pend

mul_word_20	.proc
		; AY = AY * 10 * 2
		jsr  mul_word_10
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_25	.proc
		; A=(A*2 + A)*8 + A
		sta  P8ZP_SCRATCH_REG
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		asl  a
		asl  a
		asl  a
		clc
		adc  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_25	.proc
		; AY = (AY*2 + AY) *8 + AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ZP_SCRATCH_W1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_40	.proc
		and  #7
		tay
		lda  _forties,y
		rts
_forties	.byte  0*40, 1*40, 2*40, 3*40, 4*40, 5*40, 6*40, 7*40 & 255
		.pend

mul_word_40	.proc
		; AY = (AY*4 + AY)*8
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		asl  a
		rol  P8ZP_SCRATCH_W1+1
		clc
		adc  P8ZP_SCRATCH_W2
		sta  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		adc  P8ZP_SCRATCH_W2+1
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		asl  P8ZP_SCRATCH_W1
		rol  a
		tay
		lda  P8ZP_SCRATCH_W1
		rts
		.pend

mul_byte_50	.proc
		and  #7
		tay
		lda  _fifties, y
		rts
_fifties	.byte  0*50, 1*50, 2*50, 3*50, 4*50, 5*50, 6*50 & 255, 7*50 & 255
		.pend

mul_word_50	.proc
		; AY = AY * 25 * 2
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_80	.proc
		and  #3
		tay
		lda  _eighties, y
		rts
_eighties	.byte  0*80, 1*80, 2*80, 3*80
		.pend

mul_word_80	.proc
		; AY = AY * 40 * 2
		jsr  mul_word_40
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_byte_100	.proc
		and  #3
		tay
		lda  _hundreds, y
		rts
_hundreds	.byte  0*100, 1*100, 2*100, 3*100 & 255
		.pend

mul_word_100	.proc
		; AY = AY * 25 * 4
		jsr  mul_word_25
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		ldy  P8ZP_SCRATCH_REG
		rts
		.pend

mul_word_320	.proc
		; AY = A * 256 + A * 64	 (msb in Y doesn't matter)
		sta  P8ZP_SCRATCH_B1
		ldy  #0
		sty  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		pha
		clc
		lda  P8ZP_SCRATCH_B1
		adc  P8ZP_SCRATCH_REG
		tay
		pla
		rts
		.pend

mul_word_640	.proc
		; AY = (A * 2 * 320) (msb in Y doesn't matter)
		asl  a
		jmp  mul_word_320
		.pend


; ----------- end optimized multiplications -----------


; bit shifts.
; anything below 3 is done inline. anything above 7 is done via other optimizations.

shift_left_w_7	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x

		asl  a
		rol  P8ZP_SCRATCH_B1
_shift6		asl  a
		rol  P8ZP_SCRATCH_B1
_shift5		asl  a
		rol  P8ZP_SCRATCH_B1
_shift4		asl  a
		rol  P8ZP_SCRATCH_B1
_shift3		asl  a
		rol  P8ZP_SCRATCH_B1
		asl  a
		rol  P8ZP_SCRATCH_B1
		asl  a
		rol  P8ZP_SCRATCH_B1

		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_B1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

shift_left_w_6	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift6
		.pend

shift_left_w_5	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift5
		.pend

shift_left_w_4	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift4
		.pend

shift_left_w_3	.proc
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_LO+1,x
		jmp  shift_left_w_7._shift3
		.pend


shift_left_w	.proc
		; -- variable number of shifts left
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		asl  P8ESTACK_LO+1,x
		rol  P8ESTACK_HI+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw	.proc
		; -- uword variable number of shifts right
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		lsr  P8ESTACK_HI+1,x
		ror  P8ESTACK_LO+1,x
		dey
		bne  _shift
		rts
		.pend

shift_right_uw_7	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x

		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift6		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift5		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift4		lsr  a
		ror  P8ZP_SCRATCH_B1
_shift3		lsr  a
		ror  P8ZP_SCRATCH_B1
		lsr  a
		ror  P8ZP_SCRATCH_B1
		lsr  a
		ror  P8ZP_SCRATCH_B1

		sta  P8ESTACK_HI+1,x
		lda  P8ZP_SCRATCH_B1
		sta  P8ESTACK_LO+1,x
		rts
		.pend

shift_right_uw_6	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift6
		.pend

shift_right_uw_5	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift5
		.pend

shift_right_uw_4	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift4
		.pend

shift_right_uw_3	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_B1
		lda  P8ESTACK_HI+1,x
		jmp  shift_right_uw_7._shift3
		.pend


shift_right_w_7		.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1

		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1

		lda  P8ZP_SCRATCH_W1+1
_shift6		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift5		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift4		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
_shift3		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1
		lda  P8ZP_SCRATCH_W1+1
		asl  a
		ror  P8ZP_SCRATCH_W1+1
		ror  P8ZP_SCRATCH_W1

		lda  P8ZP_SCRATCH_W1
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W1+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

shift_right_w_6	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift6
		.pend

shift_right_w_5	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift5
		.pend

shift_right_w_4	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift4
		.pend

shift_right_w_3	.proc
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		jmp  shift_right_w_7._shift3
		.pend


shift_right_w	.proc
		; -- signed word variable number of shifts right
		inx
		ldy  P8ESTACK_LO,x
		bne  _shift
		rts
_shift		lda  P8ESTACK_HI+1,x
		asl  a
		ror  P8ESTACK_HI+1,x
		ror  P8ESTACK_LO+1,x
		dey
		bne  _shift
		rts
		.pend


; support for bit shifting that is too large to be unrolled:

lsr_byte_A	.proc
		; -- lsr signed byte in A times the value in Y (assume >0)
		cmp  #0
		bmi  _negative
-		lsr  a
		dey
		bne  -
		rts
_negative	lsr  a
		ora  #$80
		dey
		bne  _negative
		rts
		.pend


square          .proc
; -- calculate square root of signed word in AY, result in AY
; routine by Lee Davsion, source: http://6502.org/source/integers/square.htm
; using this routine is about twice as fast as doing a regular multiplication.
;
; Calculates the 16 bit unsigned integer square of the signed 16 bit integer in
; Numberl/Numberh.  The result is always in the range 0 to 65025 and is held in
; Squarel/Squareh
;
; The maximum input range is only +/-255 and no checking is done to ensure that
; this is so.
;
; This routine is useful if you are trying to draw circles as for any circle
;
; x^2+y^2=r^2 where x and y are the co-ordinates of any point on the circle and
; r is the circle radius

numberl = P8ZP_SCRATCH_W1       ; number to square low byte
numberh = P8ZP_SCRATCH_W1+1     ; number to square high byte
squarel = P8ZP_SCRATCH_W2       ; square low byte
squareh = P8ZP_SCRATCH_W2+1     ; square high byte
tempsq = P8ZP_SCRATCH_B1        ; temp byte for intermediate result

	sta  numberl
	sty  numberh
	stx  P8ZP_SCRATCH_REG

        lda     #$00        ; clear a
        sta     squarel     ; clear square low byte
                            ; (no need to clear the high byte, it gets shifted out)
        lda	numberl     ; get number low byte
	ldx	numberh     ; get number high  byte
	bpl	_nonneg      ; if +ve don't negate it
                            ; else do a two's complement
	eor	#$ff        ; invert
        sec	            ; +1
	adc	#$00        ; and add it

_nonneg:
	sta	tempsq      ; save abs(number)
	ldx	#$08        ; set bit count

_nextr2bit:
	asl	squarel     ; low byte *2
	rol	squareh     ; high byte *2+carry from low
	asl	a           ; shift number byte
	bcc	_nosqadd     ; don't do add if c = 0
	tay                 ; save a
	clc                 ; clear carry for add
	lda	tempsq      ; get number
	adc	squarel     ; add number^2 low byte
	sta	squarel     ; save number^2 low byte
	lda	#$00        ; clear a
	adc	squareh     ; add number^2 high byte
	sta	squareh     ; save number^2 high byte
	tya                 ; get a back

_nosqadd:
	dex                 ; decrement bit count
	bne	_nextr2bit   ; go do next bit

	lda  squarel
	ldy  squareh
	ldx  P8ZP_SCRATCH_REG
	rts

		.pend
	;	src line: library:/prog8lib/math.p8:6

sin8u	.proc
	;	src line: library:/prog8lib/math.p8:7
		tay
		lda  _sinecos8u,y
		rts
_sinecos8u	.byte  trunc(128.0 + 127.5 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:15

cos8u	.proc
	;	src line: library:/prog8lib/math.p8:16
		tay
		lda  sin8u._sinecos8u+64,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:23

sin8	.proc
	;	src line: library:/prog8lib/math.p8:24
		tay
		lda  _sinecos8,y
		rts
_sinecos8	.char  trunc(127.0 * sin(range(256+64) * rad(360.0/256.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:32

cos8	.proc
	;	src line: library:/prog8lib/math.p8:33
		tay
		lda  sin8._sinecos8+64,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:40

sinr8u	.proc
	;	src line: library:/prog8lib/math.p8:41
		tay
		lda  _sinecosR8u,y
		rts
_sinecosR8u	.byte  trunc(128.0 + 127.5 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:49

cosr8u	.proc
	;	src line: library:/prog8lib/math.p8:50
		tay
		lda  sinr8u._sinecosR8u+45,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:57

sinr8	.proc
	;	src line: library:/prog8lib/math.p8:58
		tay
		lda  _sinecosR8,y
		rts
_sinecosR8	.char  trunc(127.0 * sin(range(180+45) * rad(360.0/180.0)))
	.pend
	;	src line: library:/prog8lib/math.p8:66

cosr8	.proc
	;	src line: library:/prog8lib/math.p8:67
		tay
		lda  sinr8._sinecosR8+45,y
		rts
	.pend
	;	src line: library:/prog8lib/math.p8:74

rnd	.proc
	;	src line: library:/prog8lib/math.p8:75
            jmp  math.randbyte
	.pend
	;	src line: library:/prog8lib/math.p8:80

rndw	.proc
	;	src line: library:/prog8lib/math.p8:81
            jmp  math.randword
	.pend
	;	src line: library:/prog8lib/math.p8:86

rndseed	.proc
	;	src line: library:/prog8lib/math.p8:88
            sta  math.randword.x1
            sty  math.randword.c1
            lda  cx16.r0L
            sta  math.randword.a1
            lda  cx16.r0H
            sta  math.randword.b1
            rts
	.pend
	.pend

; ---- block: 'txt' ----
txt	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:7
	DEFAULT_WIDTH = $50
	DEFAULT_HEIGHT = $3c
	VERA_TEXTMATRIX_BANK = 1
	VERA_TEXTMATRIX_ADDR = $b000

; non-zeropage variables
color_to_charcode	.byte  $90, $05, $1c, $9f, $9c, $1e, $1f, $9e, $81, $95, $96, $97, $98, $99, $9a, $9b
	chrout = $ffd2

	;	src line: library:/prog8lib/cx16/textio.p8:9
	;	src line: library:/prog8lib/cx16/textio.p8:10
	;	src line: library:/prog8lib/cx16/textio.p8:12
	;	src line: library:/prog8lib/cx16/textio.p8:13
	;	src line: library:/prog8lib/cx16/textio.p8:16

clear_screen	.proc
; statements
	;	src line: library:/prog8lib/cx16/textio.p8:17
	lda  #$93
	jmp  txt.chrout
	;	src line: library:/prog8lib/cx16/textio.p8:16
; variables

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:32

column	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:34
        sec
        jsr  c64.PLOT
        tay
        clc
        jmp  c64.PLOT
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:43

fill_screen	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:45
        sty  _ly+1
        phx
        pha
        jsr  c64.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00010000
        jsr  set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
        phy
_ly     ldy  #1                     ; modified
-       sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sty  cx16.VERA_DATA0
        dex
        bne  -
        ply
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       plx
        rts

set_vera_textmatrix_addresses:
        stz  cx16.VERA_CTRL
        ora  #VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L       ; start at (0,0)
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M
        rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:91

clear_screenchars	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:94
        phx
        pha
        jsr  c64.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        pla
_lx     ldx  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       plx
        rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:122

clear_screencolors	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:125
        phx
        sta  _la+1
        jsr  c64.SCREEN             ; get dimensions in X/Y
        txa
        lsr  a
        lsr  a
        sta  _lx+1
        stz  cx16.VERA_CTRL
        lda  #%00100000
        jsr  fill_screen.set_vera_textmatrix_addresses
        inc  cx16.VERA_ADDR_L       ; start at (1,0) - the color attribute byte
_lx     ldx  #0                     ; modified
_la     lda  #0                     ; modified
-       sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        dex
        bne  -
        dey
        beq  +
        lda  #1
        sta  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M       ; next line
        bra  _lx
+       plx
        rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:157
	;	src line: library:/prog8lib/cx16/textio.p8:159

color	.proc
txtcol 	= 41 	; zp UBYTE
; simple int arg(s) passed via register(s)
	sta  txtcol
; statements
	;	src line: library:/prog8lib/cx16/textio.p8:159
	;	src line: library:/prog8lib/cx16/textio.p8:160
	and  #15
	sta  txtcol
	;	src line: library:/prog8lib/cx16/textio.p8:161
	ldy  txtcol
	lda  color_to_charcode,y
	jmp  c64.CHROUT
	;	src line: library:/prog8lib/cx16/textio.p8:159
; variables

; non-zeropage variables
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:193

scroll_left	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:196
	    phx
	    jsr  c64.SCREEN
	    dex
	    stx  _lx+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00010000 | VERA_TEXTMATRIX_BANK        ; auto increment 1
        sta  cx16.VERA_ADDR_H
        lda  #2
        sta  cx16.VERA_ADDR_L   ; begin in column 1
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00010000  | VERA_TEXTMATRIX_BANK         ; auto increment 1
        sta  cx16.VERA_ADDR_H
        stz  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    plx
	    rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:239

scroll_right	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:242
	    phx
	    jsr  c64.SCREEN
	    dex
	    stx  _lx+1
	    txa
	    asl  a
	    dea
	    sta  _rcol+1
	    ina
	    ina
	    sta  _rcol2+1
        dey
        sty  P8ZP_SCRATCH_B1    ; number of rows to scroll

_nextline
        stz  cx16.VERA_CTRL     ; data port 0: source column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol   lda  #79*2-1            ; modified
        sta  cx16.VERA_ADDR_L   ; begin in rightmost column minus one
        lda  P8ZP_SCRATCH_B1
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        tay
        sty  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL     ; data port 1: destination column
        lda  #%00011000 | VERA_TEXTMATRIX_BANK        ; auto decrement 1
        sta  cx16.VERA_ADDR_H
_rcol2  lda  #79*2+1           ; modified
        sta  cx16.VERA_ADDR_L
        sty  cx16.VERA_ADDR_M

_lx     ldx  #0                 ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1    ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        bpl  _nextline

        lda  #0
        sta  cx16.VERA_CTRL
	    plx
	    rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:293

scroll_up	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:296
	    phx
	    jsr  c64.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        lda  #1 | (>VERA_TEXTMATRIX_ADDR)
        sta  cx16.VERA_ADDR_M       ; start at second line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        lda  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at top line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        inc  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    plx
	    rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:343

scroll_down	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:346
	    phx
	    jsr  c64.SCREEN
	    stx  _nextline+1
	    dey
        sty  P8ZP_SCRATCH_B1
        stz  cx16.VERA_CTRL         ; data port 0 is source
        dey
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at line before bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1 is destination
        iny
        tya
        clc
        adc  #>VERA_TEXTMATRIX_ADDR
        sta  cx16.VERA_ADDR_M       ; start at bottom line
        stz  cx16.VERA_ADDR_L
        lda  #%00010000 | VERA_TEXTMATRIX_BANK
        sta  cx16.VERA_ADDR_H       ; enable auto increment by 1, bank 0.

_nextline
        ldx  #80        ; modified
-       lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy char
        lda  cx16.VERA_DATA0
        sta  cx16.VERA_DATA1        ; copy color
        dex
        bne  -
        dec  P8ZP_SCRATCH_B1
        beq  +
        stz  cx16.VERA_CTRL         ; data port 0
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        lda  #1
        sta  cx16.VERA_CTRL         ; data port 1
        stz  cx16.VERA_ADDR_L
        dec  cx16.VERA_ADDR_M
        bra  _nextline

+       lda  #0
        sta  cx16.VERA_CTRL
	    plx
	    rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:399

	;	src line: library:/prog8lib/cx16/textio.p8:401

print	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:406
		sta  P8ZP_SCRATCH_B1
		sty  P8ZP_SCRATCH_REG
		ldy  #0
-		lda  (P8ZP_SCRATCH_B1),y
		beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:419

print_ub0	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:421
		phx
		jsr  conv.ubyte2decimal
		pha
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		txa
		jsr  c64.CHROUT
		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:436

print_ub	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:438
		phx
		jsr  conv.ubyte2decimal
_print_byte_digits
		pha
		cpy  #'0'
		beq  +
		tya
		jsr  c64.CHROUT
		pla
		jsr  c64.CHROUT
		bra  _ones
+       pla
        cmp  #'0'
        beq  _ones
        jsr  c64.CHROUT
_ones   txa
		jsr  c64.CHROUT
		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:461

print_b	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:463
		phx
		pha
		cmp  #0
		bpl  +
		lda  #'-'
		jsr  c64.CHROUT
+		pla
		jsr  conv.byte2decimal
		bra  print_ub._print_byte_digits
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:476

print_ubhex	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:478
		phx
		bcc  +
		pha
		lda  #'$'
		jsr  c64.CHROUT
		pla
+		jsr  conv.ubyte2hex
		jsr  c64.CHROUT
		tya
		jsr  c64.CHROUT
		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:494

print_ubbin	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:496
		phx
		sta  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'%'
		jsr  c64.CHROUT
+		ldy  #8
-		lda  #'0'
		asl  P8ZP_SCRATCH_B1
		bcc  +
		lda  #'1'
+		jsr  c64.CHROUT
		dey
		bne  -
		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:515

print_uwbin	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:517
		pha
		tya
		jsr  print_ubbin
		pla
		clc
		bra  print_ubbin
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:527

print_uwhex	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:530
		pha
		tya
		jsr  print_ubhex
		pla
		clc
		bra  print_ubhex
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:540

print_uw0	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:542
	    phx
		jsr  conv.uword2decimal
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
        beq  +
		jsr  c64.CHROUT
		iny
		bne  -
+		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:556

print_uw	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:558
	    phx
		jsr  conv.uword2decimal
		plx
		ldy  #0
-		lda  conv.uword2decimal.decTenThousands,y
		beq  _allzero
		cmp  #'0'
		bne  _gotdigit
		iny
		bne  -

_gotdigit
		jsr  c64.CHROUT
		iny
		lda  conv.uword2decimal.decTenThousands,y
		bne  _gotdigit
		rts
_allzero
        lda  #'0'
        jmp  c64.CHROUT
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:582

print_w	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:584
		cpy  #0
		bpl  +
		pha
		lda  #'-'
		jsr  c64.CHROUT
		tya
		eor  #255
		tay
		pla
		eor  #255
		ina
		bne +
		iny
+		bra  print_uw
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:602

input_chars	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:606
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0				; char counter = 0
-		jsr  c64.CHRIN
		cmp  #$0d			; return (ascii 13) pressed?
		beq  +				; yes, end.
		sta  (P8ZP_SCRATCH_W1),y	; else store char in buffer
		iny
		bne  -
+		lda  #0
		sta  (P8ZP_SCRATCH_W1),y	; finish string with 0 byte
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:623

setchr	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:625
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:643

getchr	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:645
            asl  a
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:662

setclr	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:666
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            txa
            asl  a
            ina
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            pla
            sta  cx16.VERA_DATA0
            rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:685

getclr	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:687
            asl  a
            ina
            pha
            stz  cx16.VERA_CTRL
            lda  #VERA_TEXTMATRIX_BANK
            sta  cx16.VERA_ADDR_H
            pla
            sta  cx16.VERA_ADDR_L
            tya
            ; clc
            adc  #>VERA_TEXTMATRIX_ADDR
            sta  cx16.VERA_ADDR_M
            lda  cx16.VERA_DATA0
            rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:766

plot	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:768
		phx
		tax
		clc
		jsr  c64.PLOT
		plx
		rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:778

width	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:780
        jsr  c64.SCREEN
        txa
        rts
	.pend
	;	src line: library:/prog8lib/cx16/textio.p8:787

height	.proc
	;	src line: library:/prog8lib/cx16/textio.p8:789
        jsr  c64.SCREEN
        tya
        rts
	.pend
	.pend

; ---- block: 'c64' ----
c64	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:4

; non-zeropage variables
	CINT = $ff81
	IOINIT = $ff84
	RAMTAS = $ff87
	RESTOR = $ff8a
	VECTOR = $ff8d
	SETMSG = $ff90
	SECOND = $ff93
	TKSA = $ff96
	MEMTOP = $ff99
	MEMBOT = $ff9c
	SCNKEY = $ff9f
	SETTMO = $ffa2
	ACPTR = $ffa5
	CIOUT = $ffa8
	UNTLK = $ffab
	UNLSN = $ffae
	LISTEN = $ffb1
	TALK = $ffb4
	READST = $ffb7
	SETLFS = $ffba
	SETNAM = $ffbd
	OPEN = $ffc0
	CLOSE = $ffc3
	CHKIN = $ffc6
	CHKOUT = $ffc9
	CLRCHN = $ffcc
	CHRIN = $ffcf
	CHROUT = $ffd2
	LOAD = $ffd5
	SAVE = $ffd8
	SETTIM = $ffdb
	RDTIM = $ffde
	STOP = $ffe1
	GETIN = $ffe4
	CLALL = $ffe7
	UDTIM = $ffea
	SCREEN = $ffed
	PLOT = $fff0
	IOBASE = $fff3

	;	src line: library:/prog8lib/cx16/syslib.p8:12

	;	src line: library:/prog8lib/cx16/syslib.p8:13

	;	src line: library:/prog8lib/cx16/syslib.p8:14

	;	src line: library:/prog8lib/cx16/syslib.p8:15

	;	src line: library:/prog8lib/cx16/syslib.p8:16

	;	src line: library:/prog8lib/cx16/syslib.p8:17

	;	src line: library:/prog8lib/cx16/syslib.p8:18

	;	src line: library:/prog8lib/cx16/syslib.p8:19

	;	src line: library:/prog8lib/cx16/syslib.p8:20

	;	src line: library:/prog8lib/cx16/syslib.p8:21

	;	src line: library:/prog8lib/cx16/syslib.p8:22

	;	src line: library:/prog8lib/cx16/syslib.p8:23

	;	src line: library:/prog8lib/cx16/syslib.p8:24

	;	src line: library:/prog8lib/cx16/syslib.p8:25

	;	src line: library:/prog8lib/cx16/syslib.p8:26

	;	src line: library:/prog8lib/cx16/syslib.p8:27

	;	src line: library:/prog8lib/cx16/syslib.p8:28

	;	src line: library:/prog8lib/cx16/syslib.p8:29

	;	src line: library:/prog8lib/cx16/syslib.p8:30

	;	src line: library:/prog8lib/cx16/syslib.p8:31

	;	src line: library:/prog8lib/cx16/syslib.p8:32

	;	src line: library:/prog8lib/cx16/syslib.p8:33

	;	src line: library:/prog8lib/cx16/syslib.p8:34

	;	src line: library:/prog8lib/cx16/syslib.p8:35

	;	src line: library:/prog8lib/cx16/syslib.p8:36

	;	src line: library:/prog8lib/cx16/syslib.p8:37

	;	src line: library:/prog8lib/cx16/syslib.p8:38

	;	src line: library:/prog8lib/cx16/syslib.p8:39

	;	src line: library:/prog8lib/cx16/syslib.p8:40

	;	src line: library:/prog8lib/cx16/syslib.p8:41

	;	src line: library:/prog8lib/cx16/syslib.p8:42

	;	src line: library:/prog8lib/cx16/syslib.p8:43

	;	src line: library:/prog8lib/cx16/syslib.p8:44

	;	src line: library:/prog8lib/cx16/syslib.p8:45

	;	src line: library:/prog8lib/cx16/syslib.p8:46

	;	src line: library:/prog8lib/cx16/syslib.p8:47

	;	src line: library:/prog8lib/cx16/syslib.p8:48

	;	src line: library:/prog8lib/cx16/syslib.p8:49

	;	src line: library:/prog8lib/cx16/syslib.p8:50

	;	src line: library:/prog8lib/cx16/syslib.p8:54

STOP2	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:56
        phx
        jsr  c64.STOP
        beq  +
        plx
        lda  #0
        rts
+       plx
        lda  #1
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:69

RDTIM16	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:71
        phx
        jsr  c64.RDTIM
        pha
        txa
        tay
        pla
        plx
        rts
	.pend
	.pend

; ---- block: 'cx16' ----
cx16	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:85
	IERROR = $0300
	IMAIN = $0302
	ICRNCH = $0304
	IQPLOP = $0306
	IGONE = $0308
	IEVAL = $030a
	SAREG = $030c
	SXREG = $030d
	SYREG = $030e
	SPREG = $030f
	USRADD = $0311
	CINV = $0314
	CBINV = $0316
	NMINV = $0318
	IOPEN = $031a
	ICLOSE = $031c
	ICHKIN = $031e
	ICKOUT = $0320
	ICLRCH = $0322
	IBASIN = $0324
	IBSOUT = $0326
	ISTOP = $0328
	IGETIN = $032a
	ICLALL = $032c
	KEYHDL = $032e
	ILOAD = $0330
	ISAVE = $0332
	NMI_VEC = $fffa
	RESET_VEC = $fffc
	IRQ_VEC = $fffe
	r0 = 2
	r1 = 4
	r2 = 6
	r3 = 8
	r4 = 10
	r5 = 12
	r6 = 14
	r7 = $10
	r8 = $12
	r9 = $14
	r10 = $16
	r11 = $18
	r12 = $1a
	r13 = $1c
	r14 = $1e
	r15 = $20
	r0s = 2
	r1s = 4
	r2s = 6
	r3s = 8
	r4s = 10
	r5s = 12
	r6s = 14
	r7s = $10
	r8s = $12
	r9s = $14
	r10s = $16
	r11s = $18
	r12s = $1a
	r13s = $1c
	r14s = $1e
	r15s = $20
	r0L = 2
	r1L = 4
	r2L = 6
	r3L = 8
	r4L = 10
	r5L = 12
	r6L = 14
	r7L = $10
	r8L = $12
	r9L = $14
	r10L = $16
	r11L = $18
	r12L = $1a
	r13L = $1c
	r14L = $1e
	r15L = $20
	r0H = 3
	r1H = 5
	r2H = 7
	r3H = 9
	r4H = 11
	r5H = 13
	r6H = 15
	r7H = $11
	r8H = $13
	r9H = $15
	r10H = $17
	r11H = $19
	r12H = $1b
	r13H = $1d
	r14H = $1f
	r15H = $21
	r0sL = 2
	r1sL = 4
	r2sL = 6
	r3sL = 8
	r4sL = 10
	r5sL = 12
	r6sL = 14
	r7sL = $10
	r8sL = $12
	r9sL = $14
	r10sL = $16
	r11sL = $18
	r12sL = $1a
	r13sL = $1c
	r14sL = $1e
	r15sL = $20
	r0sH = 3
	r1sH = 5
	r2sH = 7
	r3sH = 9
	r4sH = 11
	r5sH = 13
	r6sH = 15
	r7sH = $11
	r8sH = $13
	r9sH = $15
	r10sH = $17
	r11sH = $19
	r12sH = $1b
	r13sH = $1d
	r14sH = $1f
	r15sH = $21
	VERA_ADDR_L = $9f20
	VERA_ADDR_M = $9f21
	VERA_ADDR_H = $9f22
	VERA_DATA0 = $9f23
	VERA_DATA1 = $9f24
	VERA_CTRL = $9f25
	VERA_IEN = $9f26
	VERA_ISR = $9f27
	VERA_IRQ_LINE_L = $9f28
	VERA_DC_VIDEO = $9f29
	VERA_DC_HSCALE = $9f2a
	VERA_DC_VSCALE = $9f2b
	VERA_DC_BORDER = $9f2c
	VERA_DC_HSTART = $9f29
	VERA_DC_HSTOP = $9f2a
	VERA_DC_VSTART = $9f2b
	VERA_DC_VSTOP = $9f2c
	VERA_L0_CONFIG = $9f2d
	VERA_L0_MAPBASE = $9f2e
	VERA_L0_TILEBASE = $9f2f
	VERA_L0_HSCROLL_L = $9f30
	VERA_L0_HSCROLL_H = $9f31
	VERA_L0_VSCROLL_L = $9f32
	VERA_L0_VSCROLL_H = $9f33
	VERA_L1_CONFIG = $9f34
	VERA_L1_MAPBASE = $9f35
	VERA_L1_TILEBASE = $9f36
	VERA_L1_HSCROLL_L = $9f37
	VERA_L1_HSCROLL_H = $9f38
	VERA_L1_VSCROLL_L = $9f39
	VERA_L1_VSCROLL_H = $9f3a
	VERA_AUDIO_CTRL = $9f3b
	VERA_AUDIO_RATE = $9f3c
	VERA_AUDIO_DATA = $9f3d
	VERA_SPI_DATA = $9f3e
	VERA_SPI_CTRL = $9f3f
	d1prb = $9f00
	d1pra = $9f01
	d1ddrb = $9f02
	d1ddra = $9f03
	d1t1l = $9f04
	d1t1h = $9f05
	d1t1ll = $9f06
	d1t1lh = $9f07
	d1t2l = $9f08
	d1t2h = $9f09
	d1sr = $9f0a
	d1acr = $9f0b
	d1pcr = $9f0c
	d1ifr = $9f0d
	d1ier = $9f0e
	d1ora = $9f0f
	d2prb = $9f10
	d2pra = $9f11
	d2ddrb = $9f12
	d2ddra = $9f13
	d2t1l = $9f14
	d2t1h = $9f15
	d2t1ll = $9f16
	d2t1lh = $9f17
	d2t2l = $9f18
	d2t2h = $9f19
	d2sr = $9f1a
	d2acr = $9f1b
	d2pcr = $9f1c
	d2ifr = $9f1d
	d2ier = $9f1e
	d2ora = $9f1f
	YM_ADDRESS = $9f40
	YM_DATA = $9f41
	VERA_BASE = $9f20
	via1 = $9f00
	via2 = $9f10
	extdev = $9f60

; non-zeropage variables
	close_all = $ff4a
	lkupla = $ff59
	lkupsa = $ff5c
	screen_mode = $ff5f
	screen_set_charset = $ff62
	jsrfar = $ff6e
	fetch = $ff74
	stash = $ff77
	cmpare = $ff7a
	primm = $ff7d
	GRAPH_init = $ff20
	GRAPH_clear = $ff23
	GRAPH_set_window = $ff26
	GRAPH_set_colors = $ff29
	GRAPH_draw_line = $ff2c
	GRAPH_draw_rect = $ff2f
	GRAPH_move_rect = $ff32
	GRAPH_draw_oval = $ff35
	GRAPH_draw_image = $ff38
	GRAPH_set_font = $ff3b
	GRAPH_get_char_size = $ff3e
	GRAPH_put_char = $ff41
	GRAPH_put_next_char = $ff41
	FB_init = $fef6
	FB_get_info = $fef9
	FB_set_palette = $fefc
	FB_cursor_position = $feff
	FB_cursor_position2 = $feff
	FB_cursor_next_line = $ff02
	FB_get_pixel = $ff05
	FB_get_pixels = $ff08
	FB_set_pixel = $ff0b
	FB_set_pixels = $ff0e
	FB_set_8_pixels = $ff11
	FB_set_8_pixels_opaque = $ff14
	FB_fill_pixels = $ff17
	FB_filter_pixels = $ff1a
	FB_move_pixels = $ff1d
	i2c_read_byte = $fec6
	i2c_write_byte = $fec9
	sprite_set_image = $fef0
	sprite_set_position = $fef3
	memory_fill = $fee4
	memory_copy = $fee7
	memory_crc = $feea
	memory_decompress = $feed
	console_init = $fedb
	console_put_char = $fede
	console_get_char = $fee1
	console_put_image = $fed8
	console_set_paging_message = $fed5
	entropy_get = $fecf
	monitor = $fecc
	macptr = $ff44
	enter_basic = $ff47
	clock_set_date_time = $ff4d
	clock_get_date_time = $ff50
	kbdbuf_peek = $febd
	kbdbuf_peek2 = $febd
	kbdbuf_get_modifiers = $fec0
	kbdbuf_put = $fec3
	mouse_config = $ff68
	mouse_get = $ff6b
	mouse_scan = $ff71
	joystick_scan = $ff53
	joystick_get = $ff56
	joystick_get2 = $ff56

	;	src line: library:/prog8lib/cx16/syslib.p8:88
	;	src line: library:/prog8lib/cx16/syslib.p8:89
	;	src line: library:/prog8lib/cx16/syslib.p8:90
	;	src line: library:/prog8lib/cx16/syslib.p8:91
	;	src line: library:/prog8lib/cx16/syslib.p8:92
	;	src line: library:/prog8lib/cx16/syslib.p8:93
	;	src line: library:/prog8lib/cx16/syslib.p8:94
	;	src line: library:/prog8lib/cx16/syslib.p8:95
	;	src line: library:/prog8lib/cx16/syslib.p8:96
	;	src line: library:/prog8lib/cx16/syslib.p8:97
	;	src line: library:/prog8lib/cx16/syslib.p8:98
	;	src line: library:/prog8lib/cx16/syslib.p8:100
	;	src line: library:/prog8lib/cx16/syslib.p8:101
	;	src line: library:/prog8lib/cx16/syslib.p8:102
	;	src line: library:/prog8lib/cx16/syslib.p8:103
	;	src line: library:/prog8lib/cx16/syslib.p8:104
	;	src line: library:/prog8lib/cx16/syslib.p8:105
	;	src line: library:/prog8lib/cx16/syslib.p8:106
	;	src line: library:/prog8lib/cx16/syslib.p8:107
	;	src line: library:/prog8lib/cx16/syslib.p8:108
	;	src line: library:/prog8lib/cx16/syslib.p8:109
	;	src line: library:/prog8lib/cx16/syslib.p8:110
	;	src line: library:/prog8lib/cx16/syslib.p8:111
	;	src line: library:/prog8lib/cx16/syslib.p8:112
	;	src line: library:/prog8lib/cx16/syslib.p8:113
	;	src line: library:/prog8lib/cx16/syslib.p8:114
	;	src line: library:/prog8lib/cx16/syslib.p8:115
	;	src line: library:/prog8lib/cx16/syslib.p8:116
	;	src line: library:/prog8lib/cx16/syslib.p8:117
	;	src line: library:/prog8lib/cx16/syslib.p8:118
	;	src line: library:/prog8lib/cx16/syslib.p8:122
	;	src line: library:/prog8lib/cx16/syslib.p8:123
	;	src line: library:/prog8lib/cx16/syslib.p8:124
	;	src line: library:/prog8lib/cx16/syslib.p8:125
	;	src line: library:/prog8lib/cx16/syslib.p8:126
	;	src line: library:/prog8lib/cx16/syslib.p8:127
	;	src line: library:/prog8lib/cx16/syslib.p8:128
	;	src line: library:/prog8lib/cx16/syslib.p8:129
	;	src line: library:/prog8lib/cx16/syslib.p8:130
	;	src line: library:/prog8lib/cx16/syslib.p8:131
	;	src line: library:/prog8lib/cx16/syslib.p8:132
	;	src line: library:/prog8lib/cx16/syslib.p8:133
	;	src line: library:/prog8lib/cx16/syslib.p8:134
	;	src line: library:/prog8lib/cx16/syslib.p8:135
	;	src line: library:/prog8lib/cx16/syslib.p8:136
	;	src line: library:/prog8lib/cx16/syslib.p8:137
	;	src line: library:/prog8lib/cx16/syslib.p8:139
	;	src line: library:/prog8lib/cx16/syslib.p8:140
	;	src line: library:/prog8lib/cx16/syslib.p8:141
	;	src line: library:/prog8lib/cx16/syslib.p8:142
	;	src line: library:/prog8lib/cx16/syslib.p8:143
	;	src line: library:/prog8lib/cx16/syslib.p8:144
	;	src line: library:/prog8lib/cx16/syslib.p8:145
	;	src line: library:/prog8lib/cx16/syslib.p8:146
	;	src line: library:/prog8lib/cx16/syslib.p8:147
	;	src line: library:/prog8lib/cx16/syslib.p8:148
	;	src line: library:/prog8lib/cx16/syslib.p8:149
	;	src line: library:/prog8lib/cx16/syslib.p8:150
	;	src line: library:/prog8lib/cx16/syslib.p8:151
	;	src line: library:/prog8lib/cx16/syslib.p8:152
	;	src line: library:/prog8lib/cx16/syslib.p8:153
	;	src line: library:/prog8lib/cx16/syslib.p8:154
	;	src line: library:/prog8lib/cx16/syslib.p8:156
	;	src line: library:/prog8lib/cx16/syslib.p8:157
	;	src line: library:/prog8lib/cx16/syslib.p8:158
	;	src line: library:/prog8lib/cx16/syslib.p8:159
	;	src line: library:/prog8lib/cx16/syslib.p8:160
	;	src line: library:/prog8lib/cx16/syslib.p8:161
	;	src line: library:/prog8lib/cx16/syslib.p8:162
	;	src line: library:/prog8lib/cx16/syslib.p8:163
	;	src line: library:/prog8lib/cx16/syslib.p8:164
	;	src line: library:/prog8lib/cx16/syslib.p8:165
	;	src line: library:/prog8lib/cx16/syslib.p8:166
	;	src line: library:/prog8lib/cx16/syslib.p8:167
	;	src line: library:/prog8lib/cx16/syslib.p8:168
	;	src line: library:/prog8lib/cx16/syslib.p8:169
	;	src line: library:/prog8lib/cx16/syslib.p8:170
	;	src line: library:/prog8lib/cx16/syslib.p8:171
	;	src line: library:/prog8lib/cx16/syslib.p8:173
	;	src line: library:/prog8lib/cx16/syslib.p8:174
	;	src line: library:/prog8lib/cx16/syslib.p8:175
	;	src line: library:/prog8lib/cx16/syslib.p8:176
	;	src line: library:/prog8lib/cx16/syslib.p8:177
	;	src line: library:/prog8lib/cx16/syslib.p8:178
	;	src line: library:/prog8lib/cx16/syslib.p8:179
	;	src line: library:/prog8lib/cx16/syslib.p8:180
	;	src line: library:/prog8lib/cx16/syslib.p8:181
	;	src line: library:/prog8lib/cx16/syslib.p8:182
	;	src line: library:/prog8lib/cx16/syslib.p8:183
	;	src line: library:/prog8lib/cx16/syslib.p8:184
	;	src line: library:/prog8lib/cx16/syslib.p8:185
	;	src line: library:/prog8lib/cx16/syslib.p8:186
	;	src line: library:/prog8lib/cx16/syslib.p8:187
	;	src line: library:/prog8lib/cx16/syslib.p8:188
	;	src line: library:/prog8lib/cx16/syslib.p8:190
	;	src line: library:/prog8lib/cx16/syslib.p8:191
	;	src line: library:/prog8lib/cx16/syslib.p8:192
	;	src line: library:/prog8lib/cx16/syslib.p8:193
	;	src line: library:/prog8lib/cx16/syslib.p8:194
	;	src line: library:/prog8lib/cx16/syslib.p8:195
	;	src line: library:/prog8lib/cx16/syslib.p8:196
	;	src line: library:/prog8lib/cx16/syslib.p8:197
	;	src line: library:/prog8lib/cx16/syslib.p8:198
	;	src line: library:/prog8lib/cx16/syslib.p8:199
	;	src line: library:/prog8lib/cx16/syslib.p8:200
	;	src line: library:/prog8lib/cx16/syslib.p8:201
	;	src line: library:/prog8lib/cx16/syslib.p8:202
	;	src line: library:/prog8lib/cx16/syslib.p8:203
	;	src line: library:/prog8lib/cx16/syslib.p8:204
	;	src line: library:/prog8lib/cx16/syslib.p8:205
	;	src line: library:/prog8lib/cx16/syslib.p8:207
	;	src line: library:/prog8lib/cx16/syslib.p8:208
	;	src line: library:/prog8lib/cx16/syslib.p8:209
	;	src line: library:/prog8lib/cx16/syslib.p8:210
	;	src line: library:/prog8lib/cx16/syslib.p8:211
	;	src line: library:/prog8lib/cx16/syslib.p8:212
	;	src line: library:/prog8lib/cx16/syslib.p8:213
	;	src line: library:/prog8lib/cx16/syslib.p8:214
	;	src line: library:/prog8lib/cx16/syslib.p8:215
	;	src line: library:/prog8lib/cx16/syslib.p8:216
	;	src line: library:/prog8lib/cx16/syslib.p8:217
	;	src line: library:/prog8lib/cx16/syslib.p8:218
	;	src line: library:/prog8lib/cx16/syslib.p8:219
	;	src line: library:/prog8lib/cx16/syslib.p8:220
	;	src line: library:/prog8lib/cx16/syslib.p8:221
	;	src line: library:/prog8lib/cx16/syslib.p8:222
	;	src line: library:/prog8lib/cx16/syslib.p8:226
	;	src line: library:/prog8lib/cx16/syslib.p8:227
	;	src line: library:/prog8lib/cx16/syslib.p8:228
	;	src line: library:/prog8lib/cx16/syslib.p8:229
	;	src line: library:/prog8lib/cx16/syslib.p8:230
	;	src line: library:/prog8lib/cx16/syslib.p8:231
	;	src line: library:/prog8lib/cx16/syslib.p8:232
	;	src line: library:/prog8lib/cx16/syslib.p8:233
	;	src line: library:/prog8lib/cx16/syslib.p8:234
	;	src line: library:/prog8lib/cx16/syslib.p8:235
	;	src line: library:/prog8lib/cx16/syslib.p8:236
	;	src line: library:/prog8lib/cx16/syslib.p8:237
	;	src line: library:/prog8lib/cx16/syslib.p8:238
	;	src line: library:/prog8lib/cx16/syslib.p8:239
	;	src line: library:/prog8lib/cx16/syslib.p8:240
	;	src line: library:/prog8lib/cx16/syslib.p8:241
	;	src line: library:/prog8lib/cx16/syslib.p8:242
	;	src line: library:/prog8lib/cx16/syslib.p8:243
	;	src line: library:/prog8lib/cx16/syslib.p8:244
	;	src line: library:/prog8lib/cx16/syslib.p8:245
	;	src line: library:/prog8lib/cx16/syslib.p8:246
	;	src line: library:/prog8lib/cx16/syslib.p8:247
	;	src line: library:/prog8lib/cx16/syslib.p8:248
	;	src line: library:/prog8lib/cx16/syslib.p8:249
	;	src line: library:/prog8lib/cx16/syslib.p8:250
	;	src line: library:/prog8lib/cx16/syslib.p8:251
	;	src line: library:/prog8lib/cx16/syslib.p8:252
	;	src line: library:/prog8lib/cx16/syslib.p8:253
	;	src line: library:/prog8lib/cx16/syslib.p8:254
	;	src line: library:/prog8lib/cx16/syslib.p8:255
	;	src line: library:/prog8lib/cx16/syslib.p8:256
	;	src line: library:/prog8lib/cx16/syslib.p8:257
	;	src line: library:/prog8lib/cx16/syslib.p8:258
	;	src line: library:/prog8lib/cx16/syslib.p8:259
	;	src line: library:/prog8lib/cx16/syslib.p8:260
	;	src line: library:/prog8lib/cx16/syslib.p8:261
	;	src line: library:/prog8lib/cx16/syslib.p8:262
	;	src line: library:/prog8lib/cx16/syslib.p8:269
	;	src line: library:/prog8lib/cx16/syslib.p8:270
	;	src line: library:/prog8lib/cx16/syslib.p8:271
	;	src line: library:/prog8lib/cx16/syslib.p8:272
	;	src line: library:/prog8lib/cx16/syslib.p8:273
	;	src line: library:/prog8lib/cx16/syslib.p8:274
	;	src line: library:/prog8lib/cx16/syslib.p8:275
	;	src line: library:/prog8lib/cx16/syslib.p8:276
	;	src line: library:/prog8lib/cx16/syslib.p8:277
	;	src line: library:/prog8lib/cx16/syslib.p8:278
	;	src line: library:/prog8lib/cx16/syslib.p8:279
	;	src line: library:/prog8lib/cx16/syslib.p8:280
	;	src line: library:/prog8lib/cx16/syslib.p8:281
	;	src line: library:/prog8lib/cx16/syslib.p8:282
	;	src line: library:/prog8lib/cx16/syslib.p8:283
	;	src line: library:/prog8lib/cx16/syslib.p8:284
	;	src line: library:/prog8lib/cx16/syslib.p8:285
	;	src line: library:/prog8lib/cx16/syslib.p8:287
	;	src line: library:/prog8lib/cx16/syslib.p8:288
	;	src line: library:/prog8lib/cx16/syslib.p8:289
	;	src line: library:/prog8lib/cx16/syslib.p8:290
	;	src line: library:/prog8lib/cx16/syslib.p8:291
	;	src line: library:/prog8lib/cx16/syslib.p8:292
	;	src line: library:/prog8lib/cx16/syslib.p8:293
	;	src line: library:/prog8lib/cx16/syslib.p8:294
	;	src line: library:/prog8lib/cx16/syslib.p8:295
	;	src line: library:/prog8lib/cx16/syslib.p8:296
	;	src line: library:/prog8lib/cx16/syslib.p8:297
	;	src line: library:/prog8lib/cx16/syslib.p8:298
	;	src line: library:/prog8lib/cx16/syslib.p8:299
	;	src line: library:/prog8lib/cx16/syslib.p8:300
	;	src line: library:/prog8lib/cx16/syslib.p8:301
	;	src line: library:/prog8lib/cx16/syslib.p8:302
	;	src line: library:/prog8lib/cx16/syslib.p8:303
	;	src line: library:/prog8lib/cx16/syslib.p8:306
	;	src line: library:/prog8lib/cx16/syslib.p8:307
	;	src line: library:/prog8lib/cx16/syslib.p8:309
	;	src line: library:/prog8lib/cx16/syslib.p8:316

	;	src line: library:/prog8lib/cx16/syslib.p8:317

	;	src line: library:/prog8lib/cx16/syslib.p8:318

	;	src line: library:/prog8lib/cx16/syslib.p8:319

	;	src line: library:/prog8lib/cx16/syslib.p8:320

	;	src line: library:/prog8lib/cx16/syslib.p8:322

	;	src line: library:/prog8lib/cx16/syslib.p8:323

	;	src line: library:/prog8lib/cx16/syslib.p8:324

	;	src line: library:/prog8lib/cx16/syslib.p8:325

	;	src line: library:/prog8lib/cx16/syslib.p8:326

	;	src line: library:/prog8lib/cx16/syslib.p8:331

	;	src line: library:/prog8lib/cx16/syslib.p8:332

	;	src line: library:/prog8lib/cx16/syslib.p8:333

	;	src line: library:/prog8lib/cx16/syslib.p8:334

	;	src line: library:/prog8lib/cx16/syslib.p8:335

	;	src line: library:/prog8lib/cx16/syslib.p8:336

	;	src line: library:/prog8lib/cx16/syslib.p8:337

	;	src line: library:/prog8lib/cx16/syslib.p8:338

	;	src line: library:/prog8lib/cx16/syslib.p8:339

	;	src line: library:/prog8lib/cx16/syslib.p8:340

	;	src line: library:/prog8lib/cx16/syslib.p8:341

	;	src line: library:/prog8lib/cx16/syslib.p8:342

	;	src line: library:/prog8lib/cx16/syslib.p8:343

	;	src line: library:/prog8lib/cx16/syslib.p8:346

	;	src line: library:/prog8lib/cx16/syslib.p8:347

	;	src line: library:/prog8lib/cx16/syslib.p8:348

	;	src line: library:/prog8lib/cx16/syslib.p8:349

	;	src line: library:/prog8lib/cx16/syslib.p8:350

	;	src line: library:/prog8lib/cx16/syslib.p8:351

	;	src line: library:/prog8lib/cx16/syslib.p8:352

	;	src line: library:/prog8lib/cx16/syslib.p8:353

	;	src line: library:/prog8lib/cx16/syslib.p8:354

	;	src line: library:/prog8lib/cx16/syslib.p8:355

	;	src line: library:/prog8lib/cx16/syslib.p8:356

	;	src line: library:/prog8lib/cx16/syslib.p8:357

	;	src line: library:/prog8lib/cx16/syslib.p8:358

	;	src line: library:/prog8lib/cx16/syslib.p8:359

	;	src line: library:/prog8lib/cx16/syslib.p8:360

	;	src line: library:/prog8lib/cx16/syslib.p8:363

	;	src line: library:/prog8lib/cx16/syslib.p8:364

	;	src line: library:/prog8lib/cx16/syslib.p8:365

	;	src line: library:/prog8lib/cx16/syslib.p8:366

	;	src line: library:/prog8lib/cx16/syslib.p8:367

	;	src line: library:/prog8lib/cx16/syslib.p8:368

	;	src line: library:/prog8lib/cx16/syslib.p8:369

	;	src line: library:/prog8lib/cx16/syslib.p8:370

	;	src line: library:/prog8lib/cx16/syslib.p8:371

	;	src line: library:/prog8lib/cx16/syslib.p8:372

	;	src line: library:/prog8lib/cx16/syslib.p8:373

	;	src line: library:/prog8lib/cx16/syslib.p8:374

	;	src line: library:/prog8lib/cx16/syslib.p8:375

	;	src line: library:/prog8lib/cx16/syslib.p8:376

	;	src line: library:/prog8lib/cx16/syslib.p8:377

	;	src line: library:/prog8lib/cx16/syslib.p8:379

	;	src line: library:/prog8lib/cx16/syslib.p8:380

	;	src line: library:/prog8lib/cx16/syslib.p8:381

	;	src line: library:/prog8lib/cx16/syslib.p8:382

	;	src line: library:/prog8lib/cx16/syslib.p8:386

	;	src line: library:/prog8lib/cx16/syslib.p8:387

	;	src line: library:/prog8lib/cx16/syslib.p8:388

	;	src line: library:/prog8lib/cx16/syslib.p8:389

	;	src line: library:/prog8lib/cx16/syslib.p8:390

	;	src line: library:/prog8lib/cx16/syslib.p8:391

	;	src line: library:/prog8lib/cx16/syslib.p8:392

	;	src line: library:/prog8lib/cx16/syslib.p8:393

	;	src line: library:/prog8lib/cx16/syslib.p8:394

	;	src line: library:/prog8lib/cx16/syslib.p8:395

	;	src line: library:/prog8lib/cx16/syslib.p8:397

kbdbuf_clear	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:399
-       jsr  c64.GETIN
        bne  -
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:406

mouse_config2	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:408
        pha                         ; save shape
        sec
        jsr  cx16.screen_mode       ; set current screen mode and res in A, X, Y
        pla                         ; get shape back
        jmp  cx16.mouse_config
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:417

mouse_pos	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:420
        phx
        ldx  #cx16.r0
        jsr  cx16.mouse_get
        plx
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:435
	;	src line: library:/prog8lib/cx16/syslib.p8:442
	;	src line: library:/prog8lib/cx16/syslib.p8:449
	;	src line: library:/prog8lib/cx16/syslib.p8:456
	;	src line: library:/prog8lib/cx16/syslib.p8:463

numbanks	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:465
        phx
        sec
        jsr  c64.MEMTOP
        plx
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:474

vpeek	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:477
                pha
                lda  #1
                sta  cx16.VERA_CTRL
                pla
                and  #1
                sta  cx16.VERA_ADDR_H
                sty  cx16.VERA_ADDR_M
                stx  cx16.VERA_ADDR_L
                lda  cx16.VERA_DATA1
                rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:491

vaddr	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:493
            and  #1
            pha
            lda  cx16.r1
            and  #1
            sta  cx16.VERA_CTRL
            lda  cx16.r0
            sta  cx16.VERA_ADDR_L
            lda  cx16.r0+1
            sta  cx16.VERA_ADDR_M
            pla
            cpy  #0
            bmi  ++
            beq  +
            ora  #%00010000
+           sta  cx16.VERA_ADDR_H
            rts
+           ora  #%00011000
            sta  cx16.VERA_ADDR_H
            rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:516

vpoke	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:519
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        sty  cx16.VERA_DATA0
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:532

vpoke_or	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:535
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        ora  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:550

vpoke_and	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:553
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        and  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:568

vpoke_xor	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:571
        stz  cx16.VERA_CTRL
        and  #1
        sta  cx16.VERA_ADDR_H
        lda  cx16.r0
        sta  cx16.VERA_ADDR_L
        lda  cx16.r0+1
        sta  cx16.VERA_ADDR_M
        tya
        eor  cx16.VERA_DATA0
        sta  cx16.VERA_DATA0
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:622

init_system	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:625
        sei
        cld
        lda  VERA_DC_VIDEO
        and  #%00000111 ; retain chroma + output mode
        sta  P8ZP_SCRATCH_REG
        lda  #$80
        sta  VERA_CTRL  ; reset vera
        stz  $01        ; select rom bank 0 (enable kernal)
        jsr  c64.IOINIT
        jsr  c64.RESTOR
        jsr  c64.CINT
        lda  VERA_DC_VIDEO
        and  #%11111000
        ora  P8ZP_SCRATCH_REG
        sta  VERA_DC_VIDEO  ; keep old output mode
        lda  #$90       ; black
        jsr  c64.CHROUT
        lda  #1         ; swap fg/bg
        jsr  c64.CHROUT
        lda  #$9e       ; yellow
        jsr  c64.CHROUT
        lda  #147       ; clear screen
        jsr  c64.CHROUT
        lda  #0
        tax
        tay
        clc
        clv
        cli
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:659

init_system_phase2	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:660
        sei
        lda  cx16.CINV
        sta  restore_irq._orig_irqvec
        lda  cx16.CINV+1
        sta  restore_irq._orig_irqvec+1
        cli
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:671

cleanup_at_exit	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:673
        lda  #1
        sta  $00        ; ram bank 1
        lda  #4
        sta  $01        ; rom bank 4 (kernal)
        stz  $2d        ; hack to reset machine code monitor bank to 0
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:683

set_irq	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:684
	        sta  _modified+1
	        sty  _modified+2
	        lda  #0
	        adc  #0
	        sta  _use_kernal
		sei
		lda  #<_irq_handler
		sta  cx16.CINV
		lda  #>_irq_handler
		sta  cx16.CINV+1
                lda  cx16.VERA_IEN
                ora  #%00000001     ; enable the vsync irq
                sta  cx16.VERA_IEN
		cli
		rts

_irq_handler    jsr  _irq_handler_init
_modified	jsr  $ffff                      ; modified
		jsr  _irq_handler_end
		lda  _use_kernal
		bne  +
		; end irq processing - don't use kernal's irq handling
		lda  cx16.VERA_ISR
		ora  #1
		sta  cx16.VERA_ISR      ; clear Vera Vsync irq status
		ply
		plx
		pla
		rti
+		jmp  (restore_irq._orig_irqvec)   ; continue with normal kernal irq routine

_use_kernal     .byte  0

_irq_handler_init
		; save all zp scratch registers and the X register as these might be clobbered by the irq routine
		stx  IRQ_X_REG
		lda  P8ZP_SCRATCH_B1
		sta  IRQ_SCRATCH_ZPB1
		lda  P8ZP_SCRATCH_REG
		sta  IRQ_SCRATCH_ZPREG
		lda  P8ZP_SCRATCH_W1
		sta  IRQ_SCRATCH_ZPWORD1
		lda  P8ZP_SCRATCH_W1+1
		sta  IRQ_SCRATCH_ZPWORD1+1
		lda  P8ZP_SCRATCH_W2
		sta  IRQ_SCRATCH_ZPWORD2
		lda  P8ZP_SCRATCH_W2+1
		sta  IRQ_SCRATCH_ZPWORD2+1
		; stack protector; make sure we don't clobber the top of the evaluation stack
		dex
		dex
		dex
		dex
		dex
		dex
		cld
		rts

_irq_handler_end
		; restore all zp scratch registers and the X register
		lda  IRQ_SCRATCH_ZPB1
		sta  P8ZP_SCRATCH_B1
		lda  IRQ_SCRATCH_ZPREG
		sta  P8ZP_SCRATCH_REG
		lda  IRQ_SCRATCH_ZPWORD1
		sta  P8ZP_SCRATCH_W1
		lda  IRQ_SCRATCH_ZPWORD1+1
		sta  P8ZP_SCRATCH_W1+1
		lda  IRQ_SCRATCH_ZPWORD2
		sta  P8ZP_SCRATCH_W2
		lda  IRQ_SCRATCH_ZPWORD2+1
		sta  P8ZP_SCRATCH_W2+1
		ldx  IRQ_X_REG
		rts

IRQ_X_REG		.byte  0
IRQ_SCRATCH_ZPB1	.byte  0
IRQ_SCRATCH_ZPREG	.byte  0
IRQ_SCRATCH_ZPWORD1	.word  0
IRQ_SCRATCH_ZPWORD2	.word  0
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:769

push_vera_context	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:771
        ; note cannot store this on cpu hardware stack because this gets called as a subroutine
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+1
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+2
        lda  cx16.VERA_CTRL
        sta  _vera_storage+3
        eor  #1
        sta  cx16.VERA_CTRL
        lda  cx16.VERA_ADDR_L
        sta  _vera_storage+4
        lda  cx16.VERA_ADDR_M
        sta  _vera_storage+5
        lda  cx16.VERA_ADDR_H
        sta  _vera_storage+6
        lda  cx16.VERA_CTRL
        sta  _vera_storage+7
        rts
_vera_storage:  .byte 0,0,0,0,0,0,0,0
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:796

pop_vera_context	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:798
        lda  cx16.push_vera_context._vera_storage+7
        sta  cx16.VERA_CTRL
        lda  cx16.push_vera_context._vera_storage+6
        sta  cx16.VERA_ADDR_H
        lda  cx16.push_vera_context._vera_storage+5
        sta  cx16.VERA_ADDR_M
        lda  cx16.push_vera_context._vera_storage+4
        sta  cx16.VERA_ADDR_L
        lda  cx16.push_vera_context._vera_storage+3
        sta  cx16.VERA_CTRL
        lda  cx16.push_vera_context._vera_storage+2
        sta  cx16.VERA_ADDR_H
        lda  cx16.push_vera_context._vera_storage+1
        sta  cx16.VERA_ADDR_M
        lda  cx16.push_vera_context._vera_storage+0
        sta  cx16.VERA_ADDR_L
        rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:820

restore_irq	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:821
	    sei
	    lda  _orig_irqvec
	    sta  cx16.CINV
	    lda  _orig_irqvec+1
	    sta  cx16.CINV+1
	    lda  cx16.VERA_IEN
	    and  #%11110000     ; disable all Vera IRQs
	    ora  #%00000001     ; enable only the vsync Irq
	    sta  cx16.VERA_IEN
	    cli
	    rts
_orig_irqvec    .word  0
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:837

set_rasterirq	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:838
            sta  _modified+1
            sty  _modified+2
            lda  cx16.r0
            ldy  cx16.r0+1
            sei
            lda  cx16.VERA_IEN
            and  #%11110000     ; clear other IRQs
            ora  #%00000010     ; enable the line (raster) irq
            sta  cx16.VERA_IEN
            lda  cx16.r0
            ldy  cx16.r0+1
            jsr  set_rasterline
            lda  #<_raster_irq_handler
            sta  cx16.CINV
            lda  #>_raster_irq_handler
            sta  cx16.CINV+1
            cli
            rts

_raster_irq_handler
            jsr  set_irq._irq_handler_init
_modified   jsr  $ffff                      ; modified
            jsr  set_irq._irq_handler_end
            ; end irq processing - don't use kernal's irq handling
            lda  cx16.VERA_ISR
            ora  #%00000010
            sta  cx16.VERA_ISR      ; clear Vera line irq status
            ply
            plx
            pla
            rti
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:873

set_rasterline	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:874
        sta  cx16.VERA_IRQ_LINE_L
        lda  cx16.VERA_IEN
        and  #%01111111
        sta  cx16.VERA_IEN
        tya
        lsr  a
        ror  a
        and  #%10000000
        ora  cx16.VERA_IEN
        sta  cx16.VERA_IEN
        rts
	.pend
	.pend

; ---- block: 'sys' ----
sys	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:892
	target = $10

; non-zeropage variables

	;	src line: library:/prog8lib/cx16/syslib.p8:895
	;	src line: library:/prog8lib/cx16/syslib.p8:898

reset_system	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:900
            sei
            stz  $01                        ; bank the kernal in
            lda  #$80
            sta  cx16.VERA_CTRL             ; reset Vera (kernal doesn't do this?)
            jmp  (cx16.RESET_VEC)
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:909

wait	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:912
            phx
            sta  P8ZP_SCRATCH_W1
            sty  P8ZP_SCRATCH_W1+1

_loop       lda  P8ZP_SCRATCH_W1
            ora  P8ZP_SCRATCH_W1+1
            bne  +
            plx
            rts

+           jsr  c64.RDTIM
            sta  P8ZP_SCRATCH_B1
-           jsr  c64.RDTIM
            cmp  P8ZP_SCRATCH_B1
            beq  -

            lda  P8ZP_SCRATCH_W1
            bne  +
            dec  P8ZP_SCRATCH_W1+1
+           dec  P8ZP_SCRATCH_W1
            bra  _loop
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:937
	;	src line: library:/prog8lib/cx16/syslib.p8:946

internal_stringcopy	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:948
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  cx16.r0
		ldy  cx16.r0+1
		jmp  prog8_lib.strcpy
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:957

memcopy	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:963
            cpy  #0
            bne  _longcopy

            ; copy <= 255 bytes
            tay
            bne  _copyshort
            rts     ; nothing to copy

_copyshort
            ; decrease source and target pointers so we can simply index by Y
            lda  cx16.r0
            bne  +
            dec  cx16.r0+1
+           dec  cx16.r0
            lda  cx16.r1
            bne  +
            dec  cx16.r1+1
+           dec  cx16.r1

-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            dey
            bne  -
            rts

_longcopy
            pha                         ; lsb(count) = remainder in last page
            tya
            tax                         ; x = num pages (1+)
            ldy  #0
-           lda  (cx16.r0),y
            sta  (cx16.r1),y
            iny
            bne  -
            inc  cx16.r0+1
            inc  cx16.r1+1
            dex
            bne  -
            ply
            bne  _copyshort
            rts
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:1008

memset	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:1009
            ldy  cx16.r0
            sty  P8ZP_SCRATCH_W1
            ldy  cx16.r0+1
            sty  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            ldy  cx16.r1+1
            jmp  prog8_lib.memset
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:1020

memsetw	.proc
	;	src line: library:/prog8lib/cx16/syslib.p8:1021
            ldx  cx16.r0
            stx  P8ZP_SCRATCH_W1
            ldx  cx16.r0+1
            stx  P8ZP_SCRATCH_W1+1
            ldx  cx16.r1
            stx  P8ZP_SCRATCH_W2
            ldx  cx16.r1+1
            stx  P8ZP_SCRATCH_W2+1
            jmp  prog8_lib.memsetw
	.pend
	;	src line: library:/prog8lib/cx16/syslib.p8:1034
	;	src line: library:/prog8lib/cx16/syslib.p8:1041
	;	src line: library:/prog8lib/cx16/syslib.p8:1047
	;	src line: library:/prog8lib/cx16/syslib.p8:1053
	;	src line: library:/prog8lib/cx16/syslib.p8:1059
	;	src line: library:/prog8lib/cx16/syslib.p8:1065
	;	src line: library:/prog8lib/cx16/syslib.p8:1075
	.pend

; ---- block: 'conv' ----
conv	.proc
	;	src line: library:/prog8lib/conv.p8:3

; non-zeropage variables
string_out	; PETSCII:"????????????????"
	.byte  $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f, $3f
	.byte  $00

	;	src line: library:/prog8lib/conv.p8:7
	;	src line: library:/prog8lib/conv.p8:9

str_ub0	.proc
	;	src line: library:/prog8lib/conv.p8:11
            stx  P8ZP_SCRATCH_REG
            jsr  conv.ubyte2decimal
            sty  string_out
            sta  string_out+1
            stx  string_out+2
            lda  #0
            sta  string_out+3
            ldx  P8ZP_SCRATCH_REG
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:24

str_ub	.proc
	;	src line: library:/prog8lib/conv.p8:26
		stx  P8ZP_SCRATCH_REG
		ldy  #0
		sty  P8ZP_SCRATCH_B1
		jsr  conv.ubyte2decimal
_output_byte_digits
                ; hundreds?
		cpy  #'0'
		beq  +
		pha
		tya
		ldy  P8ZP_SCRATCH_B1
		sta  string_out,y
		pla
		inc  P8ZP_SCRATCH_B1
		; tens?
+		ldy  P8ZP_SCRATCH_B1
                cmp  #'0'
		beq  +
		sta  string_out,y
		iny
+               ; ones.
                txa
                sta  string_out,y
                iny
                lda  #0
                sta  string_out,y
                ldx  P8ZP_SCRATCH_REG
                rts
	.pend
	;	src line: library:/prog8lib/conv.p8:58

str_b	.proc
	;	src line: library:/prog8lib/conv.p8:60
            stx  P8ZP_SCRATCH_REG
            ldy  #0
            sty  P8ZP_SCRATCH_B1
            cmp  #0
            bpl  +
            pha
            lda  #'-'
            sta  string_out
            inc  P8ZP_SCRATCH_B1
            pla
+	    jsr  conv.byte2decimal
            bra  str_ub._output_byte_digits
	.pend
	;	src line: library:/prog8lib/conv.p8:76

str_ubhex	.proc
	;	src line: library:/prog8lib/conv.p8:78
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            lda  #0
            sta  string_out+2
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:88

str_ubbin	.proc
	;	src line: library:/prog8lib/conv.p8:90
	    sta  P8ZP_SCRATCH_B1
	    ldy  #0
	    sty  string_out+8
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_B1
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:107

str_uwbin	.proc
	;	src line: library:/prog8lib/conv.p8:109
	    sta  P8ZP_SCRATCH_REG
	    tya
	    jsr  str_ubbin
	    ldy  #0
	    sty  string_out+16
	    ldy  #7
-	    lsr  P8ZP_SCRATCH_REG
            bcc  +
            lda  #'1'
            bne  _digit
+           lda  #'0'
_digit      sta  string_out+8,y
            dey
	    bpl  -
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:128

str_uwhex	.proc
	;	src line: library:/prog8lib/conv.p8:130
            pha
            tya
            jsr  conv.ubyte2hex
            sta  string_out
            sty  string_out+1
            pla
            jsr  conv.ubyte2hex
            sta  string_out+2
            sty  string_out+3
            lda  #0
            sta  string_out+4
            rts
	.pend
	;	src line: library:/prog8lib/conv.p8:146

str_uw0	.proc
	;	src line: library:/prog8lib/conv.p8:148
	    stx  P8ZP_SCRATCH_REG
	    jsr  conv.uword2decimal
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            sta  string_out,y
            beq  +
            iny
            bne  -
+           ldx  P8ZP_SCRATCH_REG
	    rts
	.pend
	;	src line: library:/prog8lib/conv.p8:162

str_uw	.proc
	;	src line: library:/prog8lib/conv.p8:164
	    stx  P8ZP_SCRATCH_REG
	    jsr  conv.uword2decimal
	    ldx  #0
_output_digits
	    ldy  #0
-           lda  conv.uword2decimal.decTenThousands,y
            beq  _allzero
            cmp  #'0'
            bne  _gotdigit
            iny
            bne  -
_gotdigit   sta  string_out,x
            inx
            iny
            lda  conv.uword2decimal.decTenThousands,y
            bne  _gotdigit
_end        lda  #0
            sta  string_out,x
            ldx  P8ZP_SCRATCH_REG
            rts

_allzero    lda  #'0'
            sta  string_out,x
            inx
            bne  _end
	.pend
	;	src line: library:/prog8lib/conv.p8:193

str_w	.proc
	;	src line: library:/prog8lib/conv.p8:195
	    cpy  #0
	    bpl  str_uw
	    stx  P8ZP_SCRATCH_REG
	    pha
	    lda  #'-'
	    sta  string_out
            tya
            eor  #255
            tay
            pla
            eor  #255
            clc
            adc  #1
            bcc  +
            iny
+	    jsr  conv.uword2decimal
	    ldx  #1
	    bne  str_uw._output_digits
	;	src line: ~dummy~:0
  rts
	.pend
	;	src line: library:/prog8lib/conv.p8:220

any2uword	.proc
	;	src line: library:/prog8lib/conv.p8:226
	pha
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	ldy  P8ZP_SCRATCH_W1+1
	cmp  #'$'
	beq  _hex
	cmp  #'%'
	beq  _bin
	pla
	jsr  str2uword
	jmp  _result
_hex	pla
	jsr  hex2uword
	jmp  _result
_bin	pla
	jsr  bin2uword
_result
        pha
        lda  cx16.r15
        sta  P8ZP_SCRATCH_B1        ; result value
        pla
        sta  cx16.r15
        sty  cx16.r15+1
        lda  P8ZP_SCRATCH_B1
        rts
	.pend
	;	src line: library:/prog8lib/conv.p8:257
	;	src line: library:/prog8lib/conv.p8:267
	;	src line: library:/prog8lib/conv.p8:277

str2uword	.proc
	;	src line: library:/prog8lib/conv.p8:282
_result = P8ZP_SCRATCH_W1
        	sta  P8ZP_SCRATCH_W2
        	sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  cx16.r15+1
_loop
		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  _result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _loop
		; never reached

_result_times_10     ; (W*4 + W)*2
		lda  _result+1
		sta  P8ZP_SCRATCH_REG
		lda  _result
		asl  a
		rol  P8ZP_SCRATCH_REG
		asl  a
		rol  P8ZP_SCRATCH_REG
		clc
		adc  _result
		sta  _result
		lda  P8ZP_SCRATCH_REG
		adc  _result+1
		asl  _result
		rol  a
		sta  _result+1
		rts
	.pend
	;	src line: library:/prog8lib/conv.p8:336

str2word	.proc
	;	src line: library:/prog8lib/conv.p8:341
_result = P8ZP_SCRATCH_W1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sty  _result
		sty  _result+1
		sty  _negative
		sty  cx16.r15+1
		lda  (P8ZP_SCRATCH_W2),y
		cmp  #'+'
		bne  +
		iny
+		cmp  #'-'
		bne  _parse
		inc  _negative
		iny
_parse		lda  (P8ZP_SCRATCH_W2),y
		sec
		sbc  #48
		bpl  _digit
_done
		sty  cx16.r15
		lda  _negative
		beq  +
		sec
		lda  #0
		sbc  _result
		sta  _result
		lda  #0
		sbc  _result+1
		sta  _result+1
+		lda  _result
		ldy  _result+1
		rts
_digit
		cmp  #10
		bcs  _done
		; add digit to result
		pha
		jsr  str2uword._result_times_10
		pla
		clc
		adc  _result
		sta  _result
		bcc  +
		inc  _result+1
+		iny
		bne  _parse
		; never reached
_negative	.byte  0
	.pend
	;	src line: library:/prog8lib/conv.p8:395

hex2uword	.proc
	;	src line: library:/prog8lib/conv.p8:400
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'$'
	bne  _loop
	iny
_loop
	lda  #0
	sta  P8ZP_SCRATCH_B1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #7                 ; screencode letters A-F are 1-6
	bcc  _add_letter
	and  #127
	cmp  #97
	bcs  _try_iso            ; maybe letter is iso:'a'-iso:'f' (97-102)
	cmp  #'g'
	bcs  _stop
	cmp  #'a'
	bcs  _add_letter
	cmp  #'0'
	bcc  _stop
	cmp  #'9'+1
	bcs  _stop
_calc
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #$0f
	clc
	adc  P8ZP_SCRATCH_B1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
_add_letter
	pha
	lda  #9
	sta  P8ZP_SCRATCH_B1
	pla
	jmp  _calc
_try_iso
        cmp  #103
        bcs  _stop
        and  #63
        bne  _add_letter
	.pend
	;	src line: library:/prog8lib/conv.p8:465

bin2uword	.proc
	;	src line: library:/prog8lib/conv.p8:469
	sta  P8ZP_SCRATCH_W2
	sty  P8ZP_SCRATCH_W2+1
	ldy  #0
	sty  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	sty  cx16.r15+1
	lda  (P8ZP_SCRATCH_W2),y
	beq  _stop
	cmp  #'%'
	bne  _loop
	iny
_loop
	lda  (P8ZP_SCRATCH_W2),y
	cmp  #'0'
	bcc  _stop
	cmp  #'2'
	bcs  _stop
_first  asl  P8ZP_SCRATCH_W1
	rol  P8ZP_SCRATCH_W1+1
	and  #1
	ora  P8ZP_SCRATCH_W1
	sta  P8ZP_SCRATCH_W1
	iny
	bne  _loop
_stop
	sty  cx16.r15
	lda  P8ZP_SCRATCH_W1
	ldy  P8ZP_SCRATCH_W1+1
	rts
	.pend
	;	src line: library:/prog8lib/conv.p8:505

ubyte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:507
		ldy  #uword2decimal.ASCII_0_OFFSET
		bne  uword2decimal.hex_try200
		rts
	.pend
	;	src line: library:/prog8lib/conv.p8:514

uword2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:520
;Convert 16 bit Hex to Decimal (0-65535) Rev 2
;By Omegamatrix    Further optimizations by tepples
; routine from https://forums.nesdev.org/viewtopic.php?f=2&t=11341&start=15

;HexToDec99
; start in A
; end with A = 10's, decOnes (also in X)

;HexToDec255
; start in A
; end with Y = 100's, A = 10's, decOnes (also in X)

;HexToDec999
; start with A = high byte, Y = low byte
; end with Y = 100's, A = 10's, decOnes (also in X)
; requires 1 extra temp register on top of decOnes, could combine
; these two if HexToDec65535 was eliminated...

;HexToDec65535
; start with A/Y (low/high) as 16 bit value
; end with decTenThousand, decThousand, Y = 100's, A = 10's, decOnes (also in X)
; (irmen: I store Y and A in decHundreds and decTens too, so all of it can be easily printed)


ASCII_0_OFFSET 	= $30
temp       	    = P8ZP_SCRATCH_B1	; byte in zeropage
hexHigh      	= P8ZP_SCRATCH_W1	; byte in zeropage
hexLow       	= P8ZP_SCRATCH_W1+1	; byte in zeropage


HexToDec65535; SUBROUTINE
    sty    hexHigh               ;3  @9
    sta    hexLow                ;3  @12
    tya
    tax                          ;2  @14
    lsr    a                     ;2  @16
    lsr    a                     ;2  @18   integer divide 1024 (result 0-63)

    cpx    #$A7                  ;2  @20   account for overflow of multiplying 24 from 43,000 ($A7F8) onward,
    adc    #1                    ;2  @22   we can just round it to $A700, and the divide by 1024 is fine...

    ;at this point we have a number 1-65 that we have to times by 24,
    ;add to original sum, and Mod 1024 to get a remainder 0-999


    sta    temp                  ;3  @25
    asl    a                     ;2  @27
    adc    temp                  ;3  @30  x3
    tay                          ;2  @32
    lsr    a                     ;2  @34
    lsr    a                     ;2  @36
    lsr    a                     ;2  @38
    lsr    a                     ;2  @40
    lsr    a                     ;2  @42
    tax                          ;2  @44
    tya                          ;2  @46
    asl    a                     ;2  @48
    asl    a                     ;2  @50
    asl    a                     ;2  @52
    clc                          ;2  @54
    adc    hexLow                ;3  @57
    sta    hexLow                ;3  @60
    txa                          ;2  @62
    adc    hexHigh               ;3  @65
    sta    hexHigh               ;3  @68
    ror    a                     ;2  @70
    lsr    a                     ;2  @72
    tay                          ;2  @74    integer divide 1,000 (result 0-65)

    lsr    a                     ;2  @76    split the 1,000 and 10,000 digit
    tax                          ;2  @78
    lda    ShiftedBcdTab,x       ;4  @82
    tax                          ;2  @84
    rol    a                     ;2  @86
    and    #$0F                  ;2  @88
    ora    #ASCII_0_OFFSET
    sta    decThousands          ;3  @91
    txa                          ;2  @93
    lsr    a                     ;2  @95
    lsr    a                     ;2  @97
    lsr    a                     ;2  @99
    ora    #ASCII_0_OFFSET
    sta    decTenThousands       ;3  @102

    lda    hexLow                ;3  @105
    cpy    temp                  ;3  @108
    bmi    _doSubtract           ;2³ @110/111
    beq    _useZero               ;2³ @112/113
    adc    #23 + 24              ;2  @114
_doSubtract
    sbc    #23                   ;2  @116
    sta    hexLow                ;3  @119
_useZero
    lda    hexHigh               ;3  @122
    sbc    #0                    ;2  @124

Start100s
    and    #$03                  ;2  @126
    tax                          ;2  @128   0,1,2,3
    cmp    #2                    ;2  @130
    rol    a                     ;2  @132   0,2,5,7
    ora    #ASCII_0_OFFSET
    tay                          ;2  @134   Y = Hundreds digit

    lda    hexLow                ;3  @137
    adc    Mod100Tab,x           ;4  @141    adding remainder of 256, 512, and 256+512 (all mod 100)
    bcs    hex_doSub200             ;2³ @143/144

hex_try200
    cmp    #200                  ;2  @145
    bcc    hex_try100               ;2³ @147/148
hex_doSub200
    iny                          ;2  @149
    iny                          ;2  @151
    sbc    #200                  ;2  @153
hex_try100
    cmp    #100                  ;2  @155
    bcc    HexToDec99            ;2³ @157/158
    iny                          ;2  @159
    sbc    #100                  ;2  @161

HexToDec99; SUBROUTINE
    lsr    a                     ;2  @163
    tax                          ;2  @165
    lda    ShiftedBcdTab,x       ;4  @169
    tax                          ;2  @171
    rol    a                     ;2  @173
    and    #$0F                  ;2  @175
    ora    #ASCII_0_OFFSET
    sta    decOnes               ;3  @178
    txa                          ;2  @180
    lsr    a                     ;2  @182
    lsr    a                     ;2  @184
    lsr    a                     ;2  @186
    ora    #ASCII_0_OFFSET

    ; irmen: load X with ones, and store Y and A too, for easy printing afterwards
    sty  decHundreds
    sta  decTens
    ldx  decOnes
    rts                          ;6  @192   Y=hundreds, A = tens digit, X=ones digit


HexToDec999; SUBROUTINE
    sty    hexLow                ;3  @9
    jmp    Start100s             ;3  @12

Mod100Tab
    .byte 0,56,12,56+12

ShiftedBcdTab
    .byte $00,$01,$02,$03,$04,$08,$09,$0A,$0B,$0C
    .byte $10,$11,$12,$13,$14,$18,$19,$1A,$1B,$1C
    .byte $20,$21,$22,$23,$24,$28,$29,$2A,$2B,$2C
    .byte $30,$31,$32,$33,$34,$38,$39,$3A,$3B,$3C
    .byte $40,$41,$42,$43,$44,$48,$49,$4A,$4B,$4C

decTenThousands   	.byte  0
decThousands    	.byte  0
decHundreds		.byte  0
decTens			.byte  0
decOnes   		.byte  0
			.byte  0		; zero-terminate the decimal output string
	.pend
	;	src line: library:/prog8lib/conv.p8:689

byte2decimal	.proc
	;	src line: library:/prog8lib/conv.p8:692
		cmp  #0
		bpl  +
		eor  #255
		clc
		adc  #1
+		jmp  ubyte2decimal
	.pend
	;	src line: library:/prog8lib/conv.p8:702

ubyte2hex	.proc
	;	src line: library:/prog8lib/conv.p8:704
		stx  P8ZP_SCRATCH_REG
		pha
		and  #$0f
		tax
		ldy  _hex_digits,x
		pla
		lsr  a
		lsr  a
		lsr  a
		lsr  a
		tax
		lda  _hex_digits,x
		ldx  P8ZP_SCRATCH_REG
		rts

_hex_digits	.text "0123456789abcdef"	; can probably be reused for other stuff as well
	.pend
	;	src line: library:/prog8lib/conv.p8:724

uword2hex	.proc
	;	src line: library:/prog8lib/conv.p8:726
		sta  P8ZP_SCRATCH_REG
		tya
		jsr  ubyte2hex
		sta  output
		sty  output+1
		lda  P8ZP_SCRATCH_REG
		jsr  ubyte2hex
		sta  output+2
		sty  output+3
		rts
output		.text  "0000", $00      ; 0-terminated output buffer (to make printing easier)
	.pend
	.pend

; ---- block: 'prog8_lib' ----
prog8_lib	.proc
	;	src line: library:/prog8lib/prog8_lib.p8:3

; non-zeropage variables

	;	src line: library:/prog8lib/prog8_lib.p8:4
; Internal library routines - always included by the compiler
; Generic machine independent 6502 code.


orig_stackpointer	.byte  0	; stores the Stack pointer register at program start

read_byte_from_address_on_stack	.proc
	; -- read the byte from the memory address on the top of the stack, return in A (stack remains unchanged)
		lda  P8ESTACK_LO+1,x
		ldy  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W2),y
		rts
		.pend


write_byte_to_address_on_stack	.proc
	; -- write the byte in A to the memory address on the top of the stack (stack remains unchanged)
		ldy  P8ESTACK_LO+1,x
		sty  P8ZP_SCRATCH_W2
		ldy  P8ESTACK_HI+1,x
		sty  P8ZP_SCRATCH_W2+1
		ldy  #0
		sta  (P8ZP_SCRATCH_W2),y
		rts
		.pend



neg_b		.proc
		lda  #0
		sec
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		rts
		.pend

neg_w		.proc
		sec
		lda  #0
		sbc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  #0
		sbc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

inv_word	.proc
		lda  P8ESTACK_LO+1,x
		eor  #255
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+1,x
		eor  #255
		sta  P8ESTACK_HI+1,x
		rts
		.pend

bitand_b	.proc
		; -- bitwise and (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		and  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitor_b		.proc
		; -- bitwise or (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		ora  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitxor_b	.proc
		; -- bitwise xor (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		eor  P8ESTACK_LO+1,x
		inx
		sta  P8ESTACK_LO+1,x
		rts
		.pend

bitand_w	.proc
		; -- bitwise and (of 2 words)
		lda  P8ESTACK_LO+2,x
		and  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		and  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend

bitor_w		.proc
		; -- bitwise or (of 2 words)
		lda  P8ESTACK_LO+2,x
		ora  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		ora  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend

bitxor_w	.proc
		; -- bitwise xor (of 2 bytes)
		lda  P8ESTACK_LO+2,x
		eor  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+2,x
		eor  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+2,x
		inx
		rts
		.pend


add_w		.proc
	; -- push word+word / uword+uword
		inx
		clc
		lda  P8ESTACK_LO,x
		adc  P8ESTACK_LO+1,x
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI,x
		adc  P8ESTACK_HI+1,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

sub_w		.proc
	; -- push word-word
		inx
		sec
		lda  P8ESTACK_LO+1,x
		sbc  P8ESTACK_LO,x
		sta  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI,x
		sta  P8ESTACK_HI+1,x
		rts
		.pend

mul_byte	.proc
	; -- b*b->b (signed and unsigned)
		inx
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_LO+1,x
		jsr  math.multiply_bytes
		sta  P8ESTACK_LO+1,x
		rts
		.pend

mul_word	.proc
		inx
		lda  P8ESTACK_LO,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO+1,x
		ldy  P8ESTACK_HI+1,x
		jsr  math.multiply_words
		lda  math.multiply_words.result
		sta  P8ESTACK_LO+1,x
		lda  math.multiply_words.result+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

idiv_b		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		inx
		lda  P8ESTACK_LO,x
		eor  P8ESTACK_LO+1,x
		php			; save sign of result
		lda  P8ESTACK_LO,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num1 positive
+		tay
		inx
		lda  P8ESTACK_LO,x
		bpl  +
		eor  #$ff
		sec
		adc  #0			; make num2 positive
+		jsr  math.divmod_ub_asm
		sta  _remainder
		tya
		plp			; get sign of result
		bpl  +
		eor  #$ff
		sec
		adc  #0			; negate result
+		sta  P8ESTACK_LO,x
		dex
		rts
_remainder	.byte  0
		.pend

idiv_ub		.proc
		inx
		ldy  P8ESTACK_LO,x
		lda  P8ESTACK_LO+1,x
		jsr  math.divmod_ub_asm
		tya
		sta  P8ESTACK_LO+1,x
		rts
		.pend

idiv_w		.proc
	; signed division: use unsigned division and fix sign of result afterwards
		lda  P8ESTACK_HI+2,x
		eor  P8ESTACK_HI+1,x
		php				; save sign of result
		lda  P8ESTACK_HI+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		inx
		lda  P8ESTACK_HI+1,x
		bpl  +
		jsr  neg_w			; make value positive
+		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		sta  P8ESTACK_LO+1,x
		tya
		sta  P8ESTACK_HI+1,x
		plp
		bpl  +
		jmp  neg_w		; negate result
+		rts
		.pend

idiv_uw		.proc
		inx
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		sta  P8ESTACK_LO+1,x
		tya
		sta  P8ESTACK_HI+1,x
		rts
		.pend

remainder_ub	.proc
		inx
		ldy  P8ESTACK_LO,x	; right operand
		lda  P8ESTACK_LO+1,x  ; left operand
		jsr  math.divmod_ub_asm
		sta  P8ESTACK_LO+1,x
		rts
		.pend

remainder_uw	.proc
		inx
		lda  P8ESTACK_LO+1,x
		sta  P8ZP_SCRATCH_W1
		lda  P8ESTACK_HI+1,x
		sta  P8ZP_SCRATCH_W1+1
		lda  P8ESTACK_LO,x
		ldy  P8ESTACK_HI,x
		jsr  math.divmod_uw_asm
		lda  P8ZP_SCRATCH_W2
		sta  P8ESTACK_LO+1,x
		lda  P8ZP_SCRATCH_W2+1
		sta  P8ESTACK_HI+1,x
		rts
		.pend

equal_w		.proc
	; -- are the two words on the stack identical?
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bne  equal_b._equal_b_false
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bne  equal_b._equal_b_false
		beq  equal_b._equal_b_true
		.pend

notequal_b	.proc
	; -- are the two bytes on the stack different?
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		beq  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		.pend

notequal_w	.proc
	; -- are the two words on the stack different?
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		beq  notequal_b
		bne  equal_b._equal_b_true
		.pend

less_ub		.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

less_b		.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		sec
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_less_uw	.proc
		;  AY < P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		bcc  _true
		bne  _false
		cmp  P8ZP_SCRATCH_W2
		bcc  _true
_false		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_uw		.proc
		lda  P8ESTACK_HI+2,x
		cmp  P8ESTACK_HI+1,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

reg_less_w	.proc
		; -- AY < P8ZP_SCRATCH_W2?
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

less_w		.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+2,x
		sbc  P8ESTACK_HI+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

equal_b		.proc
	; -- are the two bytes on the stack identical?
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bne  _equal_b_false
_equal_b_true	lda  #1
_equal_b_store	inx
		sta  P8ESTACK_LO+1,x
		rts
_equal_b_false	lda  #0
		beq  _equal_b_store
		.pend

lesseq_ub	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

lesseq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		clc
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

reg_lesseq_uw	.proc
		; AY <= P8ZP_SCRATCH_W2?
		cpy  P8ZP_SCRATCH_W2+1
		beq  +
		bcc  _true
		lda  #0
		rts
+		cmp  P8ZP_SCRATCH_W2
		bcc  _true
		beq  _true
		lda  #0
		rts
_true		lda  #1
		rts
		.pend

lesseq_uw	.proc
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

reg_lesseq_w	.proc
		; -- P8ZP_SCRATCH_W2 <= AY ?   (note: order different from other routines)
		cmp  P8ZP_SCRATCH_W2
		tya
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bpl  +
		lda  #0
		rts
+		lda  #1
		rts
		.pend

lesseq_w	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI+2,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_ub	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		beq  equal_b._equal_b_false
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greater_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		clc
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greater_uw	.proc
		lda  P8ESTACK_HI+1,x
		cmp  P8ESTACK_HI+2,x
		bcc  equal_b._equal_b_true
		bne  equal_b._equal_b_false
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		bcc  equal_b._equal_b_true
		bcs  equal_b._equal_b_false
		.pend

greater_w	.proc
		lda  P8ESTACK_LO+1,x
		cmp  P8ESTACK_LO+2,x
		lda  P8ESTACK_HI+1,x
		sbc  P8ESTACK_HI+2,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_true
		bpl  equal_b._equal_b_false
		.pend

greatereq_ub	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_b	.proc
	; see http://www.6502.org/tutorials/compare_beyond.html
		lda  P8ESTACK_LO+2,x
		sec
		sbc  P8ESTACK_LO+1,x
		bvc  +
		eor  #$80
+		bpl  equal_b._equal_b_true
		bmi  equal_b._equal_b_false
		.pend

greatereq_uw	.proc
		lda  P8ESTACK_HI+2,x
		cmp  P8ESTACK_HI+1,x
		bcc  equal_b._equal_b_false
		bne  equal_b._equal_b_true
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		bcs  equal_b._equal_b_true
		bcc  equal_b._equal_b_false
		.pend

greatereq_w	.proc
		lda  P8ESTACK_LO+2,x
		cmp  P8ESTACK_LO+1,x
		lda  P8ESTACK_HI+2,x
		sbc  P8ESTACK_HI+1,x
		bvc  +
		eor  #$80
+		bmi  equal_b._equal_b_false
		bpl  equal_b._equal_b_true
		.pend


shiftleft_b	.proc
		inx
		ldy  P8ESTACK_LO,x
		bne  +
		rts
+		lda  P8ESTACK_LO+1,x
-		asl  a
		dey
		bne  -
		sta  P8ESTACK_LO+1,x
		rts
		.pend

shiftright_b	.proc
		inx
		ldy  P8ESTACK_LO,x
		bne  +
		rts
+		lda  P8ESTACK_LO+1,x
-		lsr  a
		dey
		bne  -
		sta  P8ESTACK_LO+1,x
		rts
		.pend


equalzero_b	.proc
		lda  P8ESTACK_LO+1,x
		beq  _true
		bne  _false
_true		lda  #1
		sta  P8ESTACK_LO+1,x
		rts
_false		lda  #0
		sta  P8ESTACK_LO+1,x
		rts
		.pend

equalzero_w	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

notequalzero_b	.proc
		lda  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

notequalzero_w	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lesszero_b	.proc
		lda  P8ESTACK_LO+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

lesszero_w	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._true
		jmp  equalzero_b._false
		.pend

greaterzero_ub	.proc
		lda  P8ESTACK_LO+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sb	.proc
		lda  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bpl  equalzero_b._true
		bmi  equalzero_b._false
		.pend

greaterzero_uw	.proc
		lda  P8ESTACK_LO+1,x
		ora  P8ESTACK_HI+1,x
		bne  equalzero_b._true
		beq  equalzero_b._false
		.pend

greaterzero_sw	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._false
		ora  P8ESTACK_LO+1,x
		beq  equalzero_b._false
		bne  equalzero_b._true
		.pend

lessequalzero_sb	.proc
		lda  P8ESTACK_LO+1,x
		bmi  equalzero_b._true
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

lessequalzero_sw	.proc
		lda  P8ESTACK_HI+1,x
		bmi  equalzero_b._true
		ora  P8ESTACK_LO+1,x
		beq  equalzero_b._true
		bne  equalzero_b._false
		.pend

greaterequalzero_sb	.proc
		lda  P8ESTACK_LO+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

greaterequalzero_sw	.proc
		lda  P8ESTACK_HI+1,x
	    	bpl  equalzero_b._true
	    	bmi  equalzero_b._false
		.pend

memcopy16_up	.proc
	; -- copy memory UP from (P8ZP_SCRATCH_W1) to (P8ZP_SCRATCH_W2) of length X/Y (16-bit, X=lo, Y=hi)
	;    clobbers register A,X,Y
		source = P8ZP_SCRATCH_W1
		dest = P8ZP_SCRATCH_W2
		length = P8ZP_SCRATCH_B1   ; (and SCRATCH_ZPREG)

		stx  length
		sty  length+1

		ldx  length             ; move low byte of length into X
		bne  +                  ; jump to start if X > 0
		dec  length             ; subtract 1 from length
+		ldy  #0                 ; set Y to 0
-		lda  (source),y         ; set A to whatever (source) points to offset by Y
		sta  (dest),y           ; move A to location pointed to by (dest) offset by Y
		iny                     ; increment Y
		bne  +                  ; if Y<>0 then (rolled over) then still moving bytes
		inc  source+1           ; increment hi byte of source
		inc  dest+1             ; increment hi byte of dest
+		dex                     ; decrement X (lo byte counter)
		bne  -                  ; if X<>0 then move another byte
		dec  length             ; we've moved 255 bytes, dec length
		bpl  -                  ; if length is still positive go back and move more
		rts                     ; done
		.pend


memset          .proc
	; -- fill memory from (P8ZP_SCRATCH_W1), length XY, with value in A.
	;    clobbers X, Y
		stx  P8ZP_SCRATCH_B1
		sty  _save_reg
		ldy  #0
		ldx  _save_reg
		beq  _lastpage

_fullpage	sta  (P8ZP_SCRATCH_W1),y
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page
		dex
		bne  _fullpage

_lastpage	ldy  P8ZP_SCRATCH_B1
		beq  +
-         	dey
		sta  (P8ZP_SCRATCH_W1),y
		bne  -

+           	rts
_save_reg	.byte  0
		.pend


memsetw		.proc
	; -- fill memory from (P8ZP_SCRATCH_W1) number of words in P8ZP_SCRATCH_W2, with word value in AY.
	;    clobbers A, X, Y
		sta  _mod1+1                    ; self-modify
		sty  _mod1b+1                   ; self-modify
		sta  _mod2+1                    ; self-modify
		sty  _mod2b+1                   ; self-modify
		ldx  P8ZP_SCRATCH_W1
		stx  P8ZP_SCRATCH_B1
		ldx  P8ZP_SCRATCH_W1+1
		inx
		stx  P8ZP_SCRATCH_REG                ; second page

		ldy  #0
		ldx  P8ZP_SCRATCH_W2+1
		beq  _lastpage

_fullpage
_mod1           lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
_mod1b		lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1),y        ; first page
		sta  (P8ZP_SCRATCH_B1),y            ; second page
		iny
		bne  _fullpage
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_W1+1          ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		inc  P8ZP_SCRATCH_B1+1              ; next page pair
		dex
		bne  _fullpage

_lastpage	ldx  P8ZP_SCRATCH_W2
		beq  _done

		ldy  #0
-
_mod2           lda  #0                         ; self-modified
                sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  _mod2b
		inc  P8ZP_SCRATCH_W1+1
_mod2b          lda  #0                         ; self-modified
		sta  (P8ZP_SCRATCH_W1), y
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+               dex
		bne  -
_done		rts
		.pend



ror2_mem_ub	.proc
		; -- in-place 8-bit ror of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol2_mem_ub	.proc
		; -- in-place 8-bit rol of byte at memory location in AY
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
		.pend

rol_array_ub	.proc
		; -- rol a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend


ror_array_ub	.proc
		; -- ror a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror2_array_ub	.proc
		; -- ror2 (8-bit ror) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		bcc  +
		ora  #$80
+		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

rol2_array_ub	.proc
		; -- rol2 (8-bit rol) a ubyte in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  _arg_index
		lda  (P8ZP_SCRATCH_W1),y
		cmp  #$80
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word	0
_arg_index	.byte   0
		.pend

ror_array_uw	.proc
		; -- ror a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		plp
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol_array_uw	.proc
		; -- rol a uword in an array
		php
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		plp
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

rol2_array_uw	.proc
		; -- rol2 (16-bit rol) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		lda  (P8ZP_SCRATCH_W1),y
		asl  a
		sta  (P8ZP_SCRATCH_W1),y
		iny
		lda  (P8ZP_SCRATCH_W1),y
		rol  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		dey
		lda  (P8ZP_SCRATCH_W1),y
		adc  #0
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend

ror2_array_uw	.proc
		; -- ror2 (16-bit ror) a uword in an array
		lda  _arg_target
		ldy  _arg_target+1
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		lda  _arg_index
		asl  a
		tay
		iny
		lda  (P8ZP_SCRATCH_W1),y
		lsr  a
		sta  (P8ZP_SCRATCH_W1),y
		dey
		lda  (P8ZP_SCRATCH_W1),y
		ror  a
		sta  (P8ZP_SCRATCH_W1),y
		bcc  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		ora  #$80
		sta  (P8ZP_SCRATCH_W1),y
+		rts
_arg_target	.word  0
_arg_index	.byte  0
		.pend


strcpy		.proc
		; copy a string (must be 0-terminated) from A/Y to (P8ZP_SCRATCH_W1)
		; it is assumed the target string is large enough.
		; returns the length of the string that was copied in Y.
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		ldy  #$ff
-		iny
		lda  (P8ZP_SCRATCH_W2),y
		sta  (P8ZP_SCRATCH_W1),y
		bne  -
		rts
		.pend

strcmp_expression	.proc
		; -- compare strings, result in A
		lda  _arg_s2
		ldy  _arg_s2+1
		sta  P8ZP_SCRATCH_W2
		sty  P8ZP_SCRATCH_W2+1
		lda  _arg_s1
		ldy  _arg_s1+1
		jmp  strcmp_mem
_arg_s1		.word  0
_arg_s2		.word  0
		.pend


strcmp_mem	.proc
		; --   compares strings in s1 (AY) and s2 (P8ZP_SCRATCH_W2).
		;      Returns -1,0,1 in A, depeding on the ordering. Clobbers Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
_loop		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		lda  (P8ZP_SCRATCH_W2),y
		bne  _return_minusone
		beq  _return
+		cmp  (P8ZP_SCRATCH_W2),y
		bcc  _return_minusone
		bne  _return_one
		inc  P8ZP_SCRATCH_W1
		bne  +
		inc  P8ZP_SCRATCH_W1+1
+		inc  P8ZP_SCRATCH_W2
		bne  _loop
		inc  P8ZP_SCRATCH_W2+1
		bne  _loop
_return_one
		lda  #1
_return		rts
_return_minusone
		lda  #-1
		rts
		.pend


sign_extend_stack_byte	.proc
	; -- sign extend the (signed) byte on the stack to full 16 bits
		lda  P8ESTACK_LO+1,x
		ora  #$7f
		bmi  +
		lda  #0
+		sta  P8ESTACK_HI+1,x
		rts
		.pend

strlen          .proc
        ; -- returns the number of bytes in the string in AY, in Y.
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  +
		iny
		bne  -
+		rts
		.pend


containment_bytearray	.proc
	; -- check if a value exists in a byte array.
	;    parameters: P8ZP_SCRATCH_W1: address of the byte array, A = byte to check, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
-		cmp  (P8ZP_SCRATCH_W1),y
		beq  +
		dey
		cpy  #255
		bne  -
		lda  #0
		rts
+		lda  #1
		rts
		.pend

containment_wordarray	.proc
	; -- check if a value exists in a word array.
	;    parameters: P8ZP_SCRATCH_W1: value to check, P8ZP_SCRATCH_W2: address of the word array, Y = length of array (>=1).
	;    returns boolean 0/1 in A.
		dey
		tya
		asl  a
		tay
-		lda  P8ZP_SCRATCH_W1
		cmp  (P8ZP_SCRATCH_W2),y
		bne  +
		lda  P8ZP_SCRATCH_W1+1
		iny
		cmp  (P8ZP_SCRATCH_W2),y
		beq  _found
		dey
+		dey
		dey
		cpy  #254
		bne  -
		lda  #0
		rts
_found		lda  #1
		rts
		.pend
	;	src line: library:/prog8lib/prog8_lib.p8:5
; ---- builtin functions


func_any_b_stack	.proc
		jsr  func_any_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_all_b_stack	.proc
		jsr  func_all_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_any_b_into_A	.proc
		; -- any(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  _got_any
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #0
		rts
_got_any	lda  #1
		rts
		.pend


func_all_b_into_A	.proc
		; -- all(array),  array in P8ZP_SCRATCH_W1, num bytes in A
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		beq  _got_not_all
		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
_got_not_all	rts
		.pend

func_any_w_into_A	.proc
		asl  a
		jmp  func_any_b_into_A
		.pend

func_any_w_stack	.proc
		asl  a
		jsr  func_any_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_all_w_into_A	.proc
		; -- all(warray),  array in P8ZP_SCRATCH_W1, num bytes in A
		asl  a			; times 2 because of word
		sta  _cmp_mod+1		; self-modifying code
		ldy  #0
-		lda  (P8ZP_SCRATCH_W1),y
		bne  +
		iny
		lda  (P8ZP_SCRATCH_W1),y
		bne  ++
		lda  #0
		rts
+		iny
+		iny
_cmp_mod	cpy  #255		; modified
		bne  -
		lda  #1
		rts
		.pend

func_all_w_stack	.proc
		jsr  func_all_w_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

abs_b_stack	.proc
	; -- push abs(A) on stack (as unsigned word)
		jsr  abs_b_into_AY
		sta  P8ESTACK_LO,x
		stz  P8ESTACK_HI,x
		dex
		rts
		.pend

abs_b_into_AY	.proc
	; -- AY = abs(A)  (abs always returns unsigned word)
		ldy  #0
		cmp  #0
		bmi  +
		rts
+		eor  #$ff
		clc
		adc  #1
		rts
		.pend

abs_w_stack	.proc
	; -- push abs(AY) on stack (as word)
		jsr  abs_w_into_AY
		sta  P8ESTACK_LO,x
		tya
		sta  P8ESTACK_HI,x
		dex
		rts
		.pend

abs_w_into_AY	.proc
	; -- AY = abs(AY)
		cpy  #0
		bmi  +
		rts
+		eor  #$ff
		pha
		tya
		eor  #$ff
		tay
		pla
		clc
		adc  #1
		bcc  +
		iny
+		rts
		.pend

func_sign_b_into_A	.proc
		cmp  #0
		beq  _zero
		bmi  _neg
		lda  #1
_zero		rts
_neg		lda  #-1
		rts
		.pend

func_sign_b_stack	.proc
		jsr  func_sign_b_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_ub_into_A	.proc
		cmp  #0
		bne  _pos
		rts
_pos		lda  #1
		rts
		.pend

func_sign_ub_stack	.proc
		jsr  func_sign_ub_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_uw_into_A	.proc
		cpy  #0
		beq  _possibly_zero
_pos		lda  #1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend

func_sign_uw_stack	.proc
		jsr  func_sign_uw_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sign_w_into_A	.proc
		cpy  #0
		beq  _possibly_zero
		bmi  _neg
_pos		lda  #1
		rts
_neg		lda  #-1
		rts
_possibly_zero	cmp  #0
		bne  _pos
		rts
		.pend


func_sign_w_stack	.proc
		jsr  func_sign_w_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sqrt16_stack	.proc
		jsr  func_sqrt16_into_A
		sta  P8ESTACK_LO,x
		dex
		rts
		.pend

func_sqrt16_into_A	.proc
		; integer square root from  http://6502org.wikidot.com/software-math-sqrt
		sta  P8ZP_SCRATCH_W1
		sty  P8ZP_SCRATCH_W1+1
		txa
		pha
		lda  #0
		sta  P8ZP_SCRATCH_B1
		sta  P8ZP_SCRATCH_REG
		ldx  #8
-		sec
		lda  P8ZP_SCRATCH_W1+1
		sbc  #$40
		tay
		lda  P8ZP_SCRATCH_REG
		sbc  P8ZP_SCRATCH_B1
		bcc  +
		sty  P8ZP_SCRATCH_W1+1
		sta  P8ZP_SCRATCH_REG
+		rol  P8ZP_SCRATCH_B1
		asl  P8ZP_SCRATCH_W1
		rol  P8ZP_SCRATCH_W1+1
		rol  P8ZP_SCRATCH_REG
		asl  P8ZP_SCRATCH_W1
		rol  P8ZP_SCRATCH_W1+1
		rol  P8ZP_SCRATCH_REG
		dex
		bne  -
		pla
		tax
		lda  P8ZP_SCRATCH_B1
		rts
		.pend


func_sort_ub	.proc
		; 8bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in S
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bcc  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_b	.proc
		; 8bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first, put pointer BEFORE array
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		bne  +
		dec  P8ZP_SCRATCH_W1+1
+		dec  P8ZP_SCRATCH_W1
_sortloop	ldy  P8ZP_SCRATCH_B1		;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y	;last value in (what is left of) sequence to be sorted
		sta  P8ZP_SCRATCH_REG		;save value. will be over-written by largest number
		jmp  _l2
_l1		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2+1
		bmi  _l1
_l2		sty  P8ZP_SCRATCH_W2	;index of potentially largest value
		sta  P8ZP_SCRATCH_W2+1	;potentially largest value
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1		;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2+1	;the largest value
		sta  (P8ZP_SCRATCH_W1),y	;put largest value in place
		ldy  P8ZP_SCRATCH_W2	;index of free space
		lda  P8ZP_SCRATCH_REG		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y	;put the over-written value in the free space
		dec  P8ZP_SCRATCH_B1		;end of the shorter sequence still left
		bne  _sortloop			;start working with the shorter sequence
		rts
		.pend


func_sort_uw	.proc
		; 16bit unsigned sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		cmp  P8ZP_SCRATCH_W2+1
		bne  +
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
+		bcc  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_sort_w	.proc
		; 16bit signed sort
		; sorting subroutine coded by mats rosengren (mats.rosengren@esa.int)
		; input:  address of array to sort in P8ZP_SCRATCH_W1, length in A
		; first: subtract 2 of the pointer
		asl  a
		sta  P8ZP_SCRATCH_B1
		lda  P8ZP_SCRATCH_W1
		sec
		sbc  #2
		sta  P8ZP_SCRATCH_W1
		bcs  _sort_loop
		dec  P8ZP_SCRATCH_W1+1
_sort_loop	ldy  P8ZP_SCRATCH_B1    	;start of subroutine sort
		lda  (P8ZP_SCRATCH_W1),y    ;last value in (what is left of) sequence to be sorted
		sta  _work3          		;save value. will be over-written by largest number
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  _work3+1
		dey
		jmp  _l2
_l1		dey
		dey
		beq  _l3
		lda  (P8ZP_SCRATCH_W1),y
		cmp  P8ZP_SCRATCH_W2
		iny
		lda  (P8ZP_SCRATCH_W1),y
		dey
		sbc  P8ZP_SCRATCH_W2+1
		bvc  +
		eor  #$80
+		bmi  _l1
_l2		sty  _work1          		;index of potentially largest value
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2          ;potentially largest value
		iny
		lda  (P8ZP_SCRATCH_W1),y
		sta  P8ZP_SCRATCH_W2+1
		dey
		jmp  _l1
_l3		ldy  P8ZP_SCRATCH_B1           ;where the largest value shall be put
		lda  P8ZP_SCRATCH_W2          ;the largest value
		sta  (P8ZP_SCRATCH_W1),y      ;put largest value in place
		iny
		lda  P8ZP_SCRATCH_W2+1
		sta  (P8ZP_SCRATCH_W1),y
		ldy  _work1         		 ;index of free space
		lda  _work3          		;the over-written value
		sta  (P8ZP_SCRATCH_W1),y      ;put the over-written value in the free space
		iny
		lda  _work3+1
		sta  (P8ZP_SCRATCH_W1),y
		dey
		dec  P8ZP_SCRATCH_B1           ;end of the shorter sequence still left
		dec  P8ZP_SCRATCH_B1
		bne  _sort_loop           ;start working with the shorter sequence
		rts
_work1	.byte  0
_work3	.word  0
		.pend


func_reverse_b	.proc
		; --- reverse an array of bytes (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_right = P8ZP_SCRATCH_W2
_index_left = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		sta  _loop_count
		lsr  _loop_count
		sec
		sbc  #1
		sta  _index_right
		lda  #0
		sta  _index_left
_loop		ldy  _index_right
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_left
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_right
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_left
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_left
		dec  _index_right
		dec  _loop_count
		bne  _loop
		rts
		.pend


func_reverse_w	.proc
		; --- reverse an array of words (in-place)
		; inputs:  pointer to array in P8ZP_SCRATCH_W1, length in A
_index_first = P8ZP_SCRATCH_W2
_index_second = P8ZP_SCRATCH_W2+1
_loop_count = P8ZP_SCRATCH_REG
		pha
		asl  a     ; *2 because words
		sec
		sbc  #2
		sta  _index_first
		lda  #0
		sta  _index_second
		pla
		lsr  a
		pha
		sta  _loop_count
		; first reverse the lsbs
_loop_lo	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		inc  _index_second
		inc  _index_second
		dec  _index_first
		dec  _index_first
		dec  _loop_count
		bne  _loop_lo
		; now reverse the msbs
		dec  _index_second
		inc  _index_first
		inc  _index_first
		inc  _index_first
		pla
		sta  _loop_count
_loop_hi	ldy  _index_first
		lda  (P8ZP_SCRATCH_W1),y
		pha
		ldy  _index_second
		lda  (P8ZP_SCRATCH_W1),y
		ldy  _index_first
		sta  (P8ZP_SCRATCH_W1),y
		pla
		ldy  _index_second
		sta  (P8ZP_SCRATCH_W1),y
		dec  _index_second
		dec  _index_second
		inc  _index_first
		inc  _index_first
		dec  _loop_count
		bne  _loop_hi

		rts
		.pend


func_peekw   .proc
	; -- read the word value on the address in AY
	sta  P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_W1+1
	ldy  #0
	lda  (P8ZP_SCRATCH_W1),y
	pha
	iny
	lda  (P8ZP_SCRATCH_W1),y
	tay
	pla
	rts
	.pend


func_pokew   .proc
	; -- store the word value in AY in the address in P8ZP_SCRATCH_W1
	sty  P8ZP_SCRATCH_REG
	ldy  #0
	sta  (P8ZP_SCRATCH_W1),y
	iny
	lda  P8ZP_SCRATCH_REG
	sta  (P8ZP_SCRATCH_W1),y
	rts
	.pend
	.pend
; global float constants
; memory slabs
prog8_slabs	.block
	.bend
prog8_program_end	; end of program label for progend()
